// Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "src/v8.h"

#include "src/ast-value-factory.h"
#include "src/compiler.h"
#include "src/execution.h"
#include "src/isolate.h"
#include "src/objects.h"
#include "src/parser.h"
#include "src/preparser.h"
#include "src/rewriter.h"
#include "src/scanner-character-streams.h"
#include "src/token.h"
#include "src/utils.h"

#include "test/cctest/cctest.h"

TEST(ScanKeywords) {
  struct KeywordToken {
    const char* keyword;
    i::Token::Value token;
  };

  static const KeywordToken keywords[] = {
#define KEYWORD(t, s, d) { s, i::Token::t },
      TOKEN_LIST(IGNORE_TOKEN, KEYWORD)
#undef KEYWORD
      { NULL, i::Token::IDENTIFIER }
  };

  KeywordToken key_token;
  i::UnicodeCache unicode_cache;
  i::byte buffer[32];
  for (int i = 0; (key_token = keywords[i]).keyword != NULL; i++) {
    const i::byte* keyword =
        reinterpret_cast<const i::byte*>(key_token.keyword);
    int length = i::StrLength(key_token.keyword);
    CHECK(static_cast<int>(sizeof(buffer)) >= length);
    {
      i::Utf8ToUtf16CharacterStream stream(keyword, length);
      i::Scanner scanner(&unicode_cache);
      // The scanner should parse Harmony keywords for this test.
      scanner.SetHarmonyScoping(true);
      scanner.SetHarmonyModules(true);
      scanner.Initialize(&stream);
      CHECK_EQ(key_token.token, scanner.Next());
      CHECK_EQ(i::Token::EOS, scanner.Next());
    }
    // Removing characters will make keyword matching fail.
    {
      i::Utf8ToUtf16CharacterStream stream(keyword, length - 1);
      i::Scanner scanner(&unicode_cache);
      scanner.Initialize(&stream);
      CHECK_EQ(i::Token::IDENTIFIER, scanner.Next());
      CHECK_EQ(i::Token::EOS, scanner.Next());
    }
    // Adding characters will make keyword matching fail.
    static const char chars_to_append[] = { '\x7a', '\x30', '\x5f' };
    for (int j = 0; j < static_cast<int>(ARRAY_SIZE(chars_to_append)); ++j) {
      i::MemMove(buffer, keyword, length);
      buffer[length] = chars_to_append[j];
      i::Utf8ToUtf16CharacterStream stream(buffer, length + 1);
      i::Scanner scanner(&unicode_cache);
      scanner.Initialize(&stream);
      CHECK_EQ(i::Token::IDENTIFIER, scanner.Next());
      CHECK_EQ(i::Token::EOS, scanner.Next());
    }
    // Replacing characters will make keyword matching fail.
    {
      i::MemMove(buffer, keyword, length);
      buffer[length - 1] = '\x5f';
      i::Utf8ToUtf16CharacterStream stream(buffer, length);
      i::Scanner scanner(&unicode_cache);
      scanner.Initialize(&stream);
      CHECK_EQ(i::Token::IDENTIFIER, scanner.Next());
      CHECK_EQ(i::Token::EOS, scanner.Next());
    }
  }
}


TEST(ScanHTMLEndComments) {
  v8::V8::Initialize();
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope handles(isolate);

  // Regression test. See:
  //    http://code.google.com/p/chromium/issues/detail?id=53548
  // Tests that --> is correctly interpreted as comment-to-end-of-line if there
  // is only whitespace before it on the line (with comments considered as
  // whitespace, even a multiline-comment containing a newline).
  // This was not the case if it occurred before the first real token
  // in the input.
  const char* tests[] = {
      // Before first real token.
      "\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\xa\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\x2f\x2a\x20\x70\x72\x65\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\xa\x2f\x2a\x20\x70\x72\x65\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      // After first real token.
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x34\x32\x3b\xa\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x34\x32\x3b\xa\x2f\x2a\x20\x70\x72\x65\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      NULL
  };

  const char* fail_tests[] = {
      "\x78\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\x22\x5c\x6e\x22\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\x78\x2f\x2a\x20\x70\x72\x65\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\x78\x2f\x2a\x20\x70\x72\x65\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x20\x2a\x2f\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x34\x32\x3b\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x34\x32\x3b\x20\x2f\x2a\x20\x70\x72\x65\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x20\x2a\x2f\x20\x2d\x2d\x3e\x20\x69\x73\x20\x65\x6f\x6c\x2d\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x76\x61\x72\x20\x79\x20\x3d\x20\x33\x37\x3b\xa",
      NULL
  };

  // Parser/Scanner needs a stack limit.
  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);
  uintptr_t stack_limit = CcTest::i_isolate()->stack_guard()->real_climit();
  for (int i = 0; tests[i]; i++) {
    const i::byte* source =
        reinterpret_cast<const i::byte*>(tests[i]);
    i::Utf8ToUtf16CharacterStream stream(source, i::StrLength(tests[i]));
    i::CompleteParserRecorder log;
    i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
    scanner.Initialize(&stream);
    i::PreParser preparser(&scanner, &log, stack_limit);
    preparser.set_allow_lazy(true);
    i::PreParser::PreParseResult result = preparser.PreParseProgram();
    CHECK_EQ(i::PreParser::kPreParseSuccess, result);
    CHECK(!log.HasError());
  }

  for (int i = 0; fail_tests[i]; i++) {
    const i::byte* source =
        reinterpret_cast<const i::byte*>(fail_tests[i]);
    i::Utf8ToUtf16CharacterStream stream(source, i::StrLength(fail_tests[i]));
    i::CompleteParserRecorder log;
    i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
    scanner.Initialize(&stream);
    i::PreParser preparser(&scanner, &log, stack_limit);
    preparser.set_allow_lazy(true);
    i::PreParser::PreParseResult result = preparser.PreParseProgram();
    // Even in the case of a syntax error, kPreParseSuccess is returned.
    CHECK_EQ(i::PreParser::kPreParseSuccess, result);
    CHECK(log.HasError());
  }
}


class ScriptResource : public v8::String::ExternalAsciiStringResource {
 public:
  ScriptResource(const char* data, size_t length)
      : data_(data), length_(length) { }

  const char* data() const { return data_; }
  size_t length() const { return length_; }

 private:
  const char* data_;
  size_t length_;
};


TEST(UsingCachedData) {
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope handles(isolate);
  v8::Local<v8::Context> context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(context);
  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  // Source containing functions that might be lazily compiled  and all types
  // of symbols (string, propertyName, regexp).
  const char* source =
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x34\x32\x3b"
      "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x61\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x6c\x61\x7a\x79\x28\x62\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x61\x20\x2b\x20\x62\x3b\x20\x7d\x20\x7d"
      "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x62\x61\x72\x28\x61\x29\x20\x7b\x20\x69\x66\x20\x28\x61\x29\x20\x72\x65\x74\x75\x72\x6e\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6c\x61\x7a\x79\x28\x62\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x62\x3b\x20\x7d\x20\x7d"
      "\x76\x61\x72\x20\x7a\x20\x3d\x20\x7b\x27\x73\x74\x72\x69\x6e\x67\x27\x3a\x20\x27\x73\x74\x72\x69\x6e\x67\x20\x6c\x69\x74\x65\x72\x61\x6c\x27\x2c\x20\x62\x61\x72\x65\x77\x6f\x72\x64\x3a\x20\x27\x70\x72\x6f\x70\x65\x72\x74\x79\x4e\x61\x6d\x65\x27\x2c\x20"
      "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x34\x32\x3a\x20\x27\x6e\x75\x6d\x62\x65\x72\x20\x6c\x69\x74\x65\x72\x61\x6c\x27\x2c\x20\x66\x6f\x72\x3a\x20\x27\x6b\x65\x79\x77\x6f\x72\x64\x20\x61\x73\x20\x70\x72\x6f\x70\x65\x72\x74\x79\x4e\x61\x6d\x65\x27\x2c\x20"
      "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x66\x5c\x75\x30\x30\x36\x66\x72\x3a\x20\x27\x6b\x65\x79\x77\x6f\x72\x64\x20\x70\x72\x6f\x70\x65\x72\x74\x79\x6e\x61\x6d\x65\x20\x77\x69\x74\x68\x20\x65\x73\x63\x61\x70\x65\x27\x7d\x3b"
      "\x76\x61\x72\x20\x76\x20\x3d\x20\x2f\x52\x65\x67\x45\x78\x70\x20\x4c\x69\x74\x65\x72\x61\x6c\x2f\x3b"
      "\x76\x61\x72\x20\x77\x20\x3d\x20\x2f\x52\x65\x67\x45\x78\x70\x20\x4c\x69\x74\x65\x72\x61\x6c\x5c\x75\x30\x30\x32\x30\x57\x69\x74\x68\x20\x45\x73\x63\x61\x70\x65\x2f\x67\x69\x6e\x3b"
      "\x76\x61\x72\x20\x79\x20\x3d\x20\x7b\x20\x67\x65\x74\x20\x67\x65\x74\x74\x65\x72\x28\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x34\x32\x3b\x20\x7d\x2c\x20"
      "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x73\x65\x74\x20\x73\x65\x74\x74\x65\x72\x28\x76\x29\x20\x7b\x20\x74\x68\x69\x73\x2e\x76\x61\x6c\x75\x65\x20\x3d\x20\x76\x3b\x20\x7d\x7d\x3b"
      "\x76\x61\x72\x20\x66\x20\x3d\x20\x61\x20\x3d\x3e\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x28\x62\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x61\x20\x2b\x20\x62\x3b\x20\x7d\x3b"
      "\x76\x61\x72\x20\x67\x20\x3d\x20\x61\x20\x3d\x3e\x20\x62\x20\x3d\x3e\x20\x61\x20\x2b\x20\x62\x3b";
  int source_length = i::StrLength(source);

  // ScriptResource will be deleted when the corresponding String is GCd.
  v8::ScriptCompiler::Source script_source(v8::String::NewExternal(
      isolate, new ScriptResource(source, source_length)));
  i::FLAG_harmony_arrow_functions = true;
  i::FLAG_min_preparse_length = 0;
  v8::ScriptCompiler::Compile(isolate, &script_source,
                              v8::ScriptCompiler::kProduceParserCache);
  CHECK(script_source.GetCachedData());

  // Compile the script again, using the cached data.
  bool lazy_flag = i::FLAG_lazy;
  i::FLAG_lazy = true;
  v8::ScriptCompiler::Compile(isolate, &script_source,
                              v8::ScriptCompiler::kConsumeParserCache);
  i::FLAG_lazy = false;
  v8::ScriptCompiler::CompileUnbound(isolate, &script_source,
                                     v8::ScriptCompiler::kConsumeParserCache);
  i::FLAG_lazy = lazy_flag;
}


TEST(PreparseFunctionDataIsUsed) {
  // This tests that we actually do use the function data generated by the
  // preparser.

  // Make preparsing work for short scripts.
  i::FLAG_min_preparse_length = 0;
  i::FLAG_harmony_arrow_functions = true;

  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope handles(isolate);
  v8::Local<v8::Context> context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(context);
  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  const char* good_code[] = {
      "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x68\x69\x73\x5f\x69\x73\x5f\x6c\x61\x7a\x79\x28\x29\x20\x7b\x20\x76\x61\x72\x20\x61\x3b\x20\x7d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x32\x35\x3b\x20\x7d\x20\x66\x6f\x6f\x28\x29\x3b",
      "\x76\x61\x72\x20\x74\x68\x69\x73\x5f\x69\x73\x5f\x6c\x61\x7a\x79\x20\x3d\x20\x28\x29\x20\x3d\x3e\x20\x7b\x20\x76\x61\x72\x20\x61\x3b\x20\x7d\x3b\x20\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x28\x29\x20\x3d\x3e\x20\x32\x35\x3b\x20\x66\x6f\x6f\x28\x29\x3b",
  };

  // Insert a syntax error inside the lazy function.
  const char* bad_code[] = {
      "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x68\x69\x73\x5f\x69\x73\x5f\x6c\x61\x7a\x79\x28\x29\x20\x7b\x20\x69\x66\x20\x28\x20\x20\x20\x7d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x32\x35\x3b\x20\x7d\x20\x66\x6f\x6f\x28\x29\x3b",
      "\x76\x61\x72\x20\x74\x68\x69\x73\x5f\x69\x73\x5f\x6c\x61\x7a\x79\x20\x3d\x20\x28\x29\x20\x3d\x3e\x20\x7b\x20\x69\x66\x20\x28\x20\x20\x20\x7d\x3b\x20\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x28\x29\x20\x3d\x3e\x20\x32\x35\x3b\x20\x66\x6f\x6f\x28\x29\x3b",
  };

  for (unsigned i = 0; i < ARRAY_SIZE(good_code); i++) {
    v8::ScriptCompiler::Source good_source(v8_str(good_code[i]));
    v8::ScriptCompiler::Compile(isolate, &good_source,
                                v8::ScriptCompiler::kProduceDataToCache);

    const v8::ScriptCompiler::CachedData* cached_data =
        good_source.GetCachedData();
    CHECK(cached_data->data != NULL);
    CHECK_GT(cached_data->length, 0);

    // Now compile the erroneous code with the good preparse data. If the
    // preparse data is used, the lazy function is skipped and it should
    // compile fine.
    v8::ScriptCompiler::Source bad_source(
        v8_str(bad_code[i]), new v8::ScriptCompiler::CachedData(
                                 cached_data->data, cached_data->length));
    v8::Local<v8::Value> result =
        v8::ScriptCompiler::Compile(isolate, &bad_source)->Run();
    CHECK(result->IsInt32());
    CHECK_EQ(25, result->Int32Value());
  }
}


TEST(StandAlonePreParser) {
  v8::V8::Initialize();

  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  const char* programs[] = {
      "\x7b\x6c\x61\x62\x65\x6c\x3a\x20\x34\x32\x7d",
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x34\x32\x3b",
      "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x78\x2c\x20\x79\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x78\x20\x2b\x20\x79\x3b\x20\x7d",
      "\x6c\xc1\x72\x67\x6c\x65\x42\x61\x72\x67\x6c\x65\x28\x67\x6c\x6f\x70\x29\x3b",
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x6e\x65\x77\x20\x6e\x65\x77\x20\x46\x75\x6e\x63\x74\x69\x6f\x6e\x28\x27\x74\x68\x69\x73\x2e\x78\x20\x3d\x20\x34\x32\x27\x29\x3b",
      "\x76\x61\x72\x20\x66\x20\x3d\x20\x28\x78\x2c\x20\x79\x29\x20\x3d\x3e\x20\x78\x20\x2b\x20\x79\x3b",
      NULL
  };

  uintptr_t stack_limit = CcTest::i_isolate()->stack_guard()->real_climit();
  for (int i = 0; programs[i]; i++) {
    const char* program = programs[i];
    i::Utf8ToUtf16CharacterStream stream(
        reinterpret_cast<const i::byte*>(program),
        static_cast<unsigned>(strlen(program)));
    i::CompleteParserRecorder log;
    i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
    scanner.Initialize(&stream);

    i::PreParser preparser(&scanner, &log, stack_limit);
    preparser.set_allow_lazy(true);
    preparser.set_allow_natives_syntax(true);
    preparser.set_allow_arrow_functions(true);
    i::PreParser::PreParseResult result = preparser.PreParseProgram();
    CHECK_EQ(i::PreParser::kPreParseSuccess, result);
    CHECK(!log.HasError());
  }
}


TEST(StandAlonePreParserNoNatives) {
  v8::V8::Initialize();

  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  const char* programs[] = {
      "\x6c\xc1\x72\x67\x6c\x65\x42\x61\x72\x67\x6c\x65\x28\x67\x6c\x6f\x70\x29\x3b",
      "\x76\x61\x72\x20\x78\x20\x3d\x20\x25\x5f\x49\x73\x53\x6d\x69\x28\x34\x32\x29\x3b",
      NULL
  };

  uintptr_t stack_limit = CcTest::i_isolate()->stack_guard()->real_climit();
  for (int i = 0; programs[i]; i++) {
    const char* program = programs[i];
    i::Utf8ToUtf16CharacterStream stream(
        reinterpret_cast<const i::byte*>(program),
        static_cast<unsigned>(strlen(program)));
    i::CompleteParserRecorder log;
    i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
    scanner.Initialize(&stream);

    // Preparser defaults to disallowing natives syntax.
    i::PreParser preparser(&scanner, &log, stack_limit);
    preparser.set_allow_lazy(true);
    i::PreParser::PreParseResult result = preparser.PreParseProgram();
    CHECK_EQ(i::PreParser::kPreParseSuccess, result);
    CHECK(log.HasError());
  }
}


TEST(PreparsingObjectLiterals) {
  // Regression test for a bug where the symbol stream produced by PreParser
  // didn't match what Parser wanted to consume.
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope handles(isolate);
  v8::Local<v8::Context> context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(context);
  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  {
    const char* source = "\x76\x61\x72\x20\x6d\x79\x6f\x20\x3d\x20\x7b\x69\x66\x3a\x20\x22\x66\x6f\x6f\x22\x7d\x3b\x20\x6d\x79\x6f\x2e\x69\x66\x3b";
    v8::Local<v8::Value> result = ParserCacheCompileRun(source);
    CHECK(result->IsString());
    v8::String::Utf8Value utf8(result);
    CHECK_EQ("\x66\x6f\x6f", *utf8);
  }

  {
    const char* source = "\x76\x61\x72\x20\x6d\x79\x6f\x20\x3d\x20\x7b\x22\x62\x61\x72\x22\x3a\x20\x22\x66\x6f\x6f\x22\x7d\x3b\x20\x6d\x79\x6f\x5b\x22\x62\x61\x72\x22\x5d\x3b";
    v8::Local<v8::Value> result = ParserCacheCompileRun(source);
    CHECK(result->IsString());
    v8::String::Utf8Value utf8(result);
    CHECK_EQ("\x66\x6f\x6f", *utf8);
  }

  {
    const char* source = "\x76\x61\x72\x20\x6d\x79\x6f\x20\x3d\x20\x7b\x31\x3a\x20\x22\x66\x6f\x6f\x22\x7d\x3b\x20\x6d\x79\x6f\x5b\x31\x5d\x3b";
    v8::Local<v8::Value> result = ParserCacheCompileRun(source);
    CHECK(result->IsString());
    v8::String::Utf8Value utf8(result);
    CHECK_EQ("\x66\x6f\x6f", *utf8);
  }
}


TEST(RegressChromium62639) {
  v8::V8::Initialize();
  i::Isolate* isolate = CcTest::i_isolate();

  isolate->stack_guard()->SetStackLimit(GetCurrentStackPosition() - 128 * 1024);

  const char* program = "\x76\x61\x72\x20\x78\x20\x3d\x20\x27\x73\x6f\x6d\x65\x74\x68\x69\x6e\x67\x27\x3b\xa"
                        "\x65\x73\x63\x61\x70\x65\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d";
  // Fails parsing expecting an identifier after "function".
  // Before fix, didn't check *ok after Expect(Token::Identifier, ok),
  // and then used the invalid currently scanned literal. This always
  // failed in debug mode, and sometimes crashed in release mode.

  i::Utf8ToUtf16CharacterStream stream(
      reinterpret_cast<const i::byte*>(program),
      static_cast<unsigned>(strlen(program)));
  i::CompleteParserRecorder log;
  i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
  scanner.Initialize(&stream);
  i::PreParser preparser(&scanner, &log,
                         CcTest::i_isolate()->stack_guard()->real_climit());
  preparser.set_allow_lazy(true);
  i::PreParser::PreParseResult result = preparser.PreParseProgram();
  // Even in the case of a syntax error, kPreParseSuccess is returned.
  CHECK_EQ(i::PreParser::kPreParseSuccess, result);
  CHECK(log.HasError());
}


TEST(Regress928) {
  v8::V8::Initialize();
  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();

  // Preparsing didn't consider the catch clause of a try statement
  // as with-content, which made it assume that a function inside
  // the block could be lazily compiled, and an extra, unexpected,
  // entry was added to the data.
  isolate->stack_guard()->SetStackLimit(GetCurrentStackPosition() - 128 * 1024);

  const char* program =
      "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x65\x29\x20\x7b\x20\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x28\x29\x20\x7b\x20\x2f\x2a\x20\x66\x69\x72\x73\x74\x20\x2a\x2f\x20\x7d\x20\x7d"
      "\x76\x61\x72\x20\x62\x61\x72\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x28\x29\x20\x7b\x20\x2f\x2a\x20\x73\x65\x63\x6f\x6e\x64\x20\x2a\x2f\x20\x7d";

  v8::HandleScope handles(CcTest::isolate());
  i::Handle<i::String> source = factory->NewStringFromAsciiChecked(program);
  i::GenericStringUtf16CharacterStream stream(source, 0, source->length());
  i::CompleteParserRecorder log;
  i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
  scanner.Initialize(&stream);
  i::PreParser preparser(&scanner, &log,
                         CcTest::i_isolate()->stack_guard()->real_climit());
  preparser.set_allow_lazy(true);
  i::PreParser::PreParseResult result = preparser.PreParseProgram();
  CHECK_EQ(i::PreParser::kPreParseSuccess, result);
  i::ScriptData* sd = log.GetScriptData();
  i::ParseData pd(sd);
  pd.Initialize();

  int first_function =
      static_cast<int>(strstr(program, "\x66\x75\x6e\x63\x74\x69\x6f\x6e") - program);
  int first_lbrace = first_function + i::StrLength("\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x28\x29\x20");
  CHECK_EQ('\x7b', program[first_lbrace]);
  i::FunctionEntry entry1 = pd.GetFunctionEntry(first_lbrace);
  CHECK(!entry1.is_valid());

  int second_function =
      static_cast<int>(strstr(program + first_lbrace, "\x66\x75\x6e\x63\x74\x69\x6f\x6e") - program);
  int second_lbrace =
      second_function + i::StrLength("\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x28\x29\x20");
  CHECK_EQ('\x7b', program[second_lbrace]);
  i::FunctionEntry entry2 = pd.GetFunctionEntry(second_lbrace);
  CHECK(entry2.is_valid());
  CHECK_EQ('\x7d', program[entry2.end_pos() - 1]);
  delete sd;
}


TEST(PreParseOverflow) {
  v8::V8::Initialize();

  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  size_t kProgramSize = 1024 * 1024;
  i::SmartArrayPointer<char> program(i::NewArray<char>(kProgramSize + 1));
  memset(program.get(), '\x28', kProgramSize);
  program[kProgramSize] = '\x0';

  uintptr_t stack_limit = CcTest::i_isolate()->stack_guard()->real_climit();

  i::Utf8ToUtf16CharacterStream stream(
      reinterpret_cast<const i::byte*>(program.get()),
      static_cast<unsigned>(kProgramSize));
  i::CompleteParserRecorder log;
  i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
  scanner.Initialize(&stream);

  i::PreParser preparser(&scanner, &log, stack_limit);
  preparser.set_allow_lazy(true);
  preparser.set_allow_arrow_functions(true);
  i::PreParser::PreParseResult result = preparser.PreParseProgram();
  CHECK_EQ(i::PreParser::kPreParseStackOverflow, result);
}


class TestExternalResource: public v8::String::ExternalStringResource {
 public:
  explicit TestExternalResource(uint16_t* data, int length)
      : data_(data), length_(static_cast<size_t>(length)) { }

  ~TestExternalResource() { }

  const uint16_t* data() const {
    return data_;
  }

  size_t length() const {
    return length_;
  }
 private:
  uint16_t* data_;
  size_t length_;
};


#define CHECK_EQU(v1, v2) CHECK_EQ(static_cast<int>(v1), static_cast<int>(v2))

void TestCharacterStream(const char* ascii_source,
                         unsigned length,
                         unsigned start = 0,
                         unsigned end = 0) {
  if (end == 0) end = length;
  unsigned sub_length = end - start;
  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();
  i::HandleScope test_scope(isolate);
  i::SmartArrayPointer<i::uc16> uc16_buffer(new i::uc16[length]);
  for (unsigned i = 0; i < length; i++) {
    uc16_buffer[i] = static_cast<i::uc16>(ascii_source[i]);
  }
  i::Vector<const char> ascii_vector(ascii_source, static_cast<int>(length));
  i::Handle<i::String> ascii_string =
      factory->NewStringFromAscii(ascii_vector).ToHandleChecked();
  TestExternalResource resource(uc16_buffer.get(), length);
  i::Handle<i::String> uc16_string(
      factory->NewExternalStringFromTwoByte(&resource).ToHandleChecked());

  i::ExternalTwoByteStringUtf16CharacterStream uc16_stream(
      i::Handle<i::ExternalTwoByteString>::cast(uc16_string), start, end);
  i::GenericStringUtf16CharacterStream string_stream(ascii_string, start, end);
  i::Utf8ToUtf16CharacterStream utf8_stream(
      reinterpret_cast<const i::byte*>(ascii_source), end);
  utf8_stream.SeekForward(start);

  unsigned i = start;
  while (i < end) {
    // Read streams one char at a time
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
    int32_t c0 = ascii_source[i];
    int32_t c1 = uc16_stream.Advance();
    int32_t c2 = string_stream.Advance();
    int32_t c3 = utf8_stream.Advance();
    i++;
    CHECK_EQ(c0, c1);
    CHECK_EQ(c0, c2);
    CHECK_EQ(c0, c3);
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
  }
  while (i > start + sub_length / 4) {
    // Pushback, re-read, pushback again.
    int32_t c0 = ascii_source[i - 1];
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
    uc16_stream.PushBack(c0);
    string_stream.PushBack(c0);
    utf8_stream.PushBack(c0);
    i--;
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
    int32_t c1 = uc16_stream.Advance();
    int32_t c2 = string_stream.Advance();
    int32_t c3 = utf8_stream.Advance();
    i++;
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
    CHECK_EQ(c0, c1);
    CHECK_EQ(c0, c2);
    CHECK_EQ(c0, c3);
    uc16_stream.PushBack(c0);
    string_stream.PushBack(c0);
    utf8_stream.PushBack(c0);
    i--;
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
  }
  unsigned halfway = start + sub_length / 2;
  uc16_stream.SeekForward(halfway - i);
  string_stream.SeekForward(halfway - i);
  utf8_stream.SeekForward(halfway - i);
  i = halfway;
  CHECK_EQU(i, uc16_stream.pos());
  CHECK_EQU(i, string_stream.pos());
  CHECK_EQU(i, utf8_stream.pos());

  while (i < end) {
    // Read streams one char at a time
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
    int32_t c0 = ascii_source[i];
    int32_t c1 = uc16_stream.Advance();
    int32_t c2 = string_stream.Advance();
    int32_t c3 = utf8_stream.Advance();
    i++;
    CHECK_EQ(c0, c1);
    CHECK_EQ(c0, c2);
    CHECK_EQ(c0, c3);
    CHECK_EQU(i, uc16_stream.pos());
    CHECK_EQU(i, string_stream.pos());
    CHECK_EQU(i, utf8_stream.pos());
  }

  int32_t c1 = uc16_stream.Advance();
  int32_t c2 = string_stream.Advance();
  int32_t c3 = utf8_stream.Advance();
  CHECK_LT(c1, 0);
  CHECK_LT(c2, 0);
  CHECK_LT(c3, 0);
}


TEST(CharacterStreams) {
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope handles(isolate);
  v8::Local<v8::Context> context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(context);

  TestCharacterStream("\x61\x62\x63\x0\xa\xd\x7f", 7);
  static const unsigned kBigStringSize = 4096;
  char buffer[kBigStringSize + 1];
  for (unsigned i = 0; i < kBigStringSize; i++) {
    buffer[i] = static_cast<char>(i & 0x7f);
  }
  TestCharacterStream(buffer, kBigStringSize);

  TestCharacterStream(buffer, kBigStringSize, 576, 3298);

  TestCharacterStream("\x0", 1);
  TestCharacterStream("", 0);
}


TEST(Utf8CharacterStream) {
  static const unsigned kMaxUC16CharU = unibrow::Utf8::kMaxThreeByteChar;
  static const int kMaxUC16Char = static_cast<int>(kMaxUC16CharU);

  static const int kAllUtf8CharsSize =
      (unibrow::Utf8::kMaxOneByteChar + 1) +
      (unibrow::Utf8::kMaxTwoByteChar - unibrow::Utf8::kMaxOneByteChar) * 2 +
      (unibrow::Utf8::kMaxThreeByteChar - unibrow::Utf8::kMaxTwoByteChar) * 3;
  static const unsigned kAllUtf8CharsSizeU =
      static_cast<unsigned>(kAllUtf8CharsSize);

  char buffer[kAllUtf8CharsSizeU];
  unsigned cursor = 0;
  for (int i = 0; i <= kMaxUC16Char; i++) {
    cursor += unibrow::Utf8::Encode(buffer + cursor,
                                    i,
                                    unibrow::Utf16::kNoPreviousCharacter);
  }
  DCHECK(cursor == kAllUtf8CharsSizeU);

  i::Utf8ToUtf16CharacterStream stream(reinterpret_cast<const i::byte*>(buffer),
                                       kAllUtf8CharsSizeU);
  for (int i = 0; i <= kMaxUC16Char; i++) {
    CHECK_EQU(i, stream.pos());
    int32_t c = stream.Advance();
    CHECK_EQ(i, c);
    CHECK_EQU(i + 1, stream.pos());
  }
  for (int i = kMaxUC16Char; i >= 0; i--) {
    CHECK_EQU(i + 1, stream.pos());
    stream.PushBack(i);
    CHECK_EQU(i, stream.pos());
  }
  int i = 0;
  while (stream.pos() < kMaxUC16CharU) {
    CHECK_EQU(i, stream.pos());
    unsigned progress = stream.SeekForward(12);
    i += progress;
    int32_t c = stream.Advance();
    if (i <= kMaxUC16Char) {
      CHECK_EQ(i, c);
    } else {
      CHECK_EQ(-1, c);
    }
    i += 1;
    CHECK_EQU(i, stream.pos());
  }
}

#undef CHECK_EQU

void TestStreamScanner(i::Utf16CharacterStream* stream,
                       i::Token::Value* expected_tokens,
                       int skip_pos = 0,  // Zero means not skipping.
                       int skip_to = 0) {
  i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
  scanner.Initialize(stream);

  int i = 0;
  do {
    i::Token::Value expected = expected_tokens[i];
    i::Token::Value actual = scanner.Next();
    CHECK_EQ(i::Token::String(expected), i::Token::String(actual));
    if (scanner.location().end_pos == skip_pos) {
      scanner.SeekForward(skip_to);
    }
    i++;
  } while (expected_tokens[i] != i::Token::ILLEGAL);
}


TEST(StreamScanner) {
  v8::V8::Initialize();

  const char* str1 = "\x7b\x20\x66\x6f\x6f\x20\x67\x65\x74\x20\x66\x6f\x72\x20\x3a\x20\x2a\x2f\x20\x3c\x2d\x20\xa\xa\x20\x2f\x2a\x66\x6f\x6f\x2a\x2f\x20\x62\x69\x62";
  i::Utf8ToUtf16CharacterStream stream1(reinterpret_cast<const i::byte*>(str1),
                                        static_cast<unsigned>(strlen(str1)));
  i::Token::Value expectations1[] = {
      i::Token::LBRACE,
      i::Token::IDENTIFIER,
      i::Token::IDENTIFIER,
      i::Token::FOR,
      i::Token::COLON,
      i::Token::MUL,
      i::Token::DIV,
      i::Token::LT,
      i::Token::SUB,
      i::Token::IDENTIFIER,
      i::Token::EOS,
      i::Token::ILLEGAL
  };
  TestStreamScanner(&stream1, expectations1, 0, 0);

  const char* str2 = "\x63\x61\x73\x65\x20\x64\x65\x66\x61\x75\x6c\x74\x20\x63\x6f\x6e\x73\x74\x20\x7b\x54\x48\x49\x53\xa\x50\x41\x52\x54\xa\x53\x4b\x49\x50\x50\x45\x44\x7d\x20\x64\x6f";
  i::Utf8ToUtf16CharacterStream stream2(reinterpret_cast<const i::byte*>(str2),
                                        static_cast<unsigned>(strlen(str2)));
  i::Token::Value expectations2[] = {
      i::Token::CASE,
      i::Token::DEFAULT,
      i::Token::CONST,
      i::Token::LBRACE,
      // Skipped part here
      i::Token::RBRACE,
      i::Token::DO,
      i::Token::EOS,
      i::Token::ILLEGAL
  };
  DCHECK_EQ('\x7b', str2[19]);
  DCHECK_EQ('\x7d', str2[37]);
  TestStreamScanner(&stream2, expectations2, 20, 37);

  const char* str3 = "\x7b\x7d\x7d\x7d\x7d";
  i::Token::Value expectations3[] = {
      i::Token::LBRACE,
      i::Token::RBRACE,
      i::Token::RBRACE,
      i::Token::RBRACE,
      i::Token::RBRACE,
      i::Token::EOS,
      i::Token::ILLEGAL
  };
  // Skip zero-four RBRACEs.
  for (int i = 0; i <= 4; i++) {
     expectations3[6 - i] = i::Token::ILLEGAL;
     expectations3[5 - i] = i::Token::EOS;
     i::Utf8ToUtf16CharacterStream stream3(
         reinterpret_cast<const i::byte*>(str3),
         static_cast<unsigned>(strlen(str3)));
     TestStreamScanner(&stream3, expectations3, 1, 1 + i);
  }
}


void TestScanRegExp(const char* re_source, const char* expected) {
  i::Utf8ToUtf16CharacterStream stream(
       reinterpret_cast<const i::byte*>(re_source),
       static_cast<unsigned>(strlen(re_source)));
  i::HandleScope scope(CcTest::i_isolate());
  i::Scanner scanner(CcTest::i_isolate()->unicode_cache());
  scanner.Initialize(&stream);

  i::Token::Value start = scanner.peek();
  CHECK(start == i::Token::DIV || start == i::Token::ASSIGN_DIV);
  CHECK(scanner.ScanRegExpPattern(start == i::Token::ASSIGN_DIV));
  scanner.Next();  // Current token is now the regexp literal.
  i::Zone zone(CcTest::i_isolate());
  i::AstValueFactory ast_value_factory(&zone,
                                       CcTest::i_isolate()->heap()->HashSeed());
  ast_value_factory.Internalize(CcTest::i_isolate());
  i::Handle<i::String> val =
      scanner.CurrentSymbol(&ast_value_factory)->string();
  i::DisallowHeapAllocation no_alloc;
  i::String::FlatContent content = val->GetFlatContent();
  CHECK(content.IsAscii());
  i::Vector<const uint8_t> actual = content.ToOneByteVector();
  for (int i = 0; i < actual.length(); i++) {
    CHECK_NE('\x0', expected[i]);
    CHECK_EQ(expected[i], actual[i]);
  }
}


TEST(RegExpScanning) {
  v8::V8::Initialize();

  // RegExp token with added garbage at the end. The scanner should only
  // scan the RegExp until the terminating slash just before "flipperwald".
  TestScanRegExp("\x2f\x62\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x62");
  // Incomplete escape sequences doesn't hide the terminating slash.
  TestScanRegExp("\x2f\x5c\x78\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x78");
  TestScanRegExp("\x2f\x5c\x75\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x75");
  TestScanRegExp("\x2f\x5c\x75\x31\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x75\x31");
  TestScanRegExp("\x2f\x5c\x75\x31\x32\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x75\x31\x32");
  TestScanRegExp("\x2f\x5c\x75\x31\x32\x33\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x75\x31\x32\x33");
  TestScanRegExp("\x2f\x5c\x63\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x63");
  TestScanRegExp("\x2f\x5c\x63\x2f\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x63");
  // Slashes inside character classes are not terminating.
  TestScanRegExp("\x2f\x5b\x2f\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x2f\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x73\x2d\x2f\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x73\x2d\x2f\x5d");
  // Incomplete escape sequences inside a character class doesn't hide
  // the end of the character class.
  TestScanRegExp("\x2f\x5b\x5c\x63\x2f\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x63\x2f\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x63\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x63\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x78\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x78\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x78\x31\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x78\x31\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x75\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x75\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x75\x31\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x75\x31\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x75\x31\x32\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x75\x31\x32\x5d");
  TestScanRegExp("\x2f\x5b\x5c\x75\x31\x32\x33\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x75\x31\x32\x33\x5d");
  // Escaped ']'s wont end the character class.
  TestScanRegExp("\x2f\x5b\x5c\x5d\x2f\x5d\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5b\x5c\x5d\x2f\x5d");
  // Escaped slashes are not terminating.
  TestScanRegExp("\x2f\x5c\x2f\x2f\x66\x6c\x69\x70\x70\x65\x72\x77\x61\x6c\x64", "\x5c\x2f");
  // Starting with '=' works too.
  TestScanRegExp("\x2f\x3d\x2f", "\x3d");
  TestScanRegExp("\x2f\x3d\x3f\x2f", "\x3d\x3f");
}


static int Utf8LengthHelper(const char* s) {
  int len = i::StrLength(s);
  int character_length = len;
  for (int i = 0; i < len; i++) {
    unsigned char c = s[i];
    int input_offset = 0;
    int output_adjust = 0;
    if (c > 0x7f) {
      if (c < 0xc0) continue;
      if (c >= 0xf0) {
        if (c >= 0xf8) {
          // 5 and 6 byte UTF-8 sequences turn into a kBadChar for each UTF-8
          // byte.
          continue;  // Handle first UTF-8 byte.
        }
        if ((c & 7) == 0 && ((s[i + 1] & 0x30) == 0)) {
          // This 4 byte sequence could have been coded as a 3 byte sequence.
          // Record a single kBadChar for the first byte and continue.
          continue;
        }
        input_offset = 3;
        // 4 bytes of UTF-8 turn into 2 UTF-16 code units.
        character_length -= 2;
      } else if (c >= 0xe0) {
        if ((c & 0xf) == 0 && ((s[i + 1] & 0x20) == 0)) {
          // This 3 byte sequence could have been coded as a 2 byte sequence.
          // Record a single kBadChar for the first byte and continue.
          continue;
        }
        input_offset = 2;
        // 3 bytes of UTF-8 turn into 1 UTF-16 code unit.
        output_adjust = 2;
      } else {
        if ((c & 0x1e) == 0) {
          // This 2 byte sequence could have been coded as a 1 byte sequence.
          // Record a single kBadChar for the first byte and continue.
          continue;
        }
        input_offset = 1;
        // 2 bytes of UTF-8 turn into 1 UTF-16 code unit.
        output_adjust = 1;
      }
      bool bad = false;
      for (int j = 1; j <= input_offset; j++) {
        if ((s[i + j] & 0xc0) != 0x80) {
          // Bad UTF-8 sequence turns the first in the sequence into kBadChar,
          // which is a single UTF-16 code unit.
          bad = true;
          break;
        }
      }
      if (!bad) {
        i += input_offset;
        character_length -= output_adjust;
      }
    }
  }
  return character_length;
}


TEST(ScopePositions) {
  v8::internal::FLAG_harmony_scoping = true;

  // Test the parser for correctly setting the start and end positions
  // of a scope. We check the scope positions of exactly one scope
  // nested in the global scope of a program. 'inner source' is the
  // source code that determines the part of the source belonging
  // to the nested scope. 'outer_prefix' and 'outer_suffix' are
  // parts of the source that belong to the global scope.
  struct SourceData {
    const char* outer_prefix;
    const char* inner_source;
    const char* outer_suffix;
    i::ScopeType scope_type;
    i::StrictMode strict_mode;
  };

  const SourceData source_data[] = {
    { "\x20\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20", "\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x20\x6d\x6f\x72\x65\x3b", i::WITH_SCOPE, i::SLOPPY },
    { "\x20\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20", "\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x3b\x20\x6d\x6f\x72\x65\x3b", i::WITH_SCOPE, i::SLOPPY },
    { "\x20\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20", "\x7b\xa"
      "\x20\x20\x20\x20\x62\x6c\x6f\x63\x6b\x3b\xa"
      "\x20\x20\x7d", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::WITH_SCOPE, i::SLOPPY },
    { "\x20\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20", "\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x3b", "\x20\x6d\x6f\x72\x65\x3b", i::WITH_SCOPE, i::SLOPPY },
    { "\x20\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20", "\x73\x74\x61\x74\x65\x6d\x65\x6e\x74", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::WITH_SCOPE, i::SLOPPY },
    { "\x20\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\xa"
      "\x20\x20\x20\x20", "\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x3b", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::WITH_SCOPE, i::SLOPPY },
    { "\x20\x20\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x20", "\x28\x65\x29\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x20\x6d\x6f\x72\x65\x3b",
      i::CATCH_SCOPE, i::SLOPPY },
    { "\x20\x20\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x20", "\x28\x65\x29\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x3b\x20\x6d\x6f\x72\x65\x3b",
      i::CATCH_SCOPE, i::SLOPPY },
    { "\x20\x20\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x20", "\x28\x65\x29\x20\x7b\xa"
      "\x20\x20\x20\x20\x62\x6c\x6f\x63\x6b\x3b\xa"
      "\x20\x20\x7d", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::CATCH_SCOPE, i::SLOPPY },
    { "\x20\x20\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x20", "\x28\x65\x29\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x20\x66\x69\x6e\x61\x6c\x6c\x79\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d\x20\x6d\x6f\x72\x65\x3b",
      i::CATCH_SCOPE, i::SLOPPY },
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa"
      "\x20\x20", "\x7b\x20\x6c\x65\x74\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa"
      "\x20\x20", "\x7b\x20\x6c\x65\x74\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x3b\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa"
      "\x20\x20", "\x7b\xa"
      "\x20\x20\x20\x20\x6c\x65\x74\x20\x62\x6c\x6f\x63\x6b\x3b\xa"
      "\x20\x20\x7d", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa"
      "\x20\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x20\x6d\x6f\x72\x65\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa"
      "\x20\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\xa"
      "\x20\x20\x20\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\xa"
      "\x20\x20\x7d", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::FUNCTION_SCOPE, i::SLOPPY },
    // TODO(aperez): Change to use i::ARROW_SCOPE when implemented
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa", "\x28\x61\x2c\x62\x29\x20\x3d\x3e\x20\x61\x20\x2b\x20\x62", "\x3b\x20\x6d\x6f\x72\x65\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa", "\x28\x61\x2c\x62\x29\x20\x3d\x3e\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x61\x2b\x62\x3b\x20\x7d", "\xa\x6d\x6f\x72\x65\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    { "\x20\x20\x73\x74\x61\x72\x74\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x3d\x20\x31\x20\x3b\x20\x78\x20\x3c\x20\x31\x30\x3b\x20\x2b\x2b\x20\x78\x29\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x20\x6d\x6f\x72\x65\x3b",
      i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x3d\x20\x31\x20\x3b\x20\x78\x20\x3c\x20\x31\x30\x3b\x20\x2b\x2b\x20\x78\x29\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x3b\x20\x6d\x6f\x72\x65\x3b",
      i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x3d\x20\x31\x20\x3b\x20\x78\x20\x3c\x20\x31\x30\x3b\x20\x2b\x2b\x20\x78\x29\x20\x7b\xa"
      "\x20\x20\x20\x20\x62\x6c\x6f\x63\x6b\x3b\xa"
      "\x20\x20\x7d", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x3d\x20\x31\x20\x3b\x20\x78\x20\x3c\x20\x31\x30\x3b\x20\x2b\x2b\x20\x78\x29\x20\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x3b", "\x20\x6d\x6f\x72\x65\x3b",
      i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x3d\x20\x31\x20\x3b\x20\x78\x20\x3c\x20\x31\x30\x3b\x20\x2b\x2b\x20\x78\x29\x20\x73\x74\x61\x74\x65\x6d\x65\x6e\x74", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x3d\x20\x31\x20\x3b\x20\x78\x20\x3c\x20\x31\x30\x3b\x20\x2b\x2b\x20\x78\x29\xa"
      "\x20\x20\x20\x20\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x3b", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x69\x6e\x20\x7b\x7d\x29\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x20\x6d\x6f\x72\x65\x3b",
      i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x69\x6e\x20\x7b\x7d\x29\x20\x7b\x20\x62\x6c\x6f\x63\x6b\x3b\x20\x7d", "\x3b\x20\x6d\x6f\x72\x65\x3b",
      i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x69\x6e\x20\x7b\x7d\x29\x20\x7b\xa"
      "\x20\x20\x20\x20\x62\x6c\x6f\x63\x6b\x3b\xa"
      "\x20\x20\x7d", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x69\x6e\x20\x7b\x7d\x29\x20\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x3b", "\x20\x6d\x6f\x72\x65\x3b",
      i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x69\x6e\x20\x7b\x7d\x29\x20\x73\x74\x61\x74\x65\x6d\x65\x6e\x74", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    { "\x20\x20\x66\x6f\x72\x20", "\x28\x6c\x65\x74\x20\x78\x20\x69\x6e\x20\x7b\x7d\x29\xa"
      "\x20\x20\x20\x20\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x3b", "\xa"
      "\x20\x20\x6d\x6f\x72\x65\x3b", i::BLOCK_SCOPE, i::STRICT },
    // Check that 6-byte and 4-byte encodings of UTF-8 strings do not throw
    // the preparser off in terms of byte offsets.
    // 6 byte encoding.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x35\x35\x5c\x32\x34\x30\x5c\x32\x30\x31\x5c\x33\x35\x35\x5c\x32\x36\x30\x5c\x32\x31\x31\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // 4 byte encoding.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x36\x30\x5c\x32\x32\x30\x5c\x32\x32\x30\x5c\x32\x31\x32\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // 3 byte encoding of \u0fff.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x34\x30\x5c\x32\x37\x37\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Broken 6 byte encoding with missing last byte.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x35\x35\x5c\x32\x34\x30\x5c\x32\x30\x31\x5c\x33\x35\x35\x5c\x32\x31\x31\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Broken 3 byte encoding of \u0fff with missing last byte.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x34\x30\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Broken 3 byte encoding of \u0fff with missing 2 last bytes.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x34\x30\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Broken 3 byte encoding of \u00ff should be a 2 byte encoding.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x34\x30\x5c\x32\x30\x33\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Broken 3 byte encoding of \u007f should be a 2 byte encoding.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x34\x30\x5c\x32\x30\x31\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Unpaired lead surrogate.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x35\x35\x5c\x32\x34\x30\x5c\x32\x30\x31\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Unpaired lead surrogate where following code point is a 3 byte sequence.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x35\x35\x5c\x32\x34\x30\x5c\x32\x30\x31\x5c\x33\x34\x30\x5c\x32\x37\x37\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Unpaired lead surrogate where following code point is a 4 byte encoding
    // of a trail surrogate.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x35\x35\x5c\x32\x34\x30\x5c\x32\x30\x31\x5c\x33\x36\x30\x5c\x32\x31\x35\x5c\x32\x36\x30\x5c\x32\x31\x31\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Unpaired trail surrogate.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x35\x35\x5c\x32\x36\x30\x5c\x32\x31\x31\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // 2 byte encoding of \u00ff.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x30\x33\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Broken 2 byte encoding of \u00ff with missing last byte.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x30\x33\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Broken 2 byte encoding of \u007f should be a 1 byte encoding.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x30\x31\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Illegal 5 byte encoding.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x37\x30\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Illegal 6 byte encoding.
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x37\x34\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Illegal 0xfe byte
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x37\x36\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    // Illegal 0xff byte
    { "\x20\x20\x27\x66\x6f\x6f\x5c\x33\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x5c\x32\x37\x37\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x69\x6e\x66\x75\x6e\x63\x74\x69\x6f\x6e\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    { "\x20\x20\x27\x66\x6f\x6f\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x27\x62\x61\x72\x5c\x33\x35\x35\x5c\x32\x34\x30\x5c\x32\x30\x31\x5c\x33\x35\x35\x5c\x32\x36\x30\x5c\x32\x31\x33\x27\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    { "\x20\x20\x27\x66\x6f\x6f\x27\x3b\xa"
      "\x20\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x75\x6e", "\x28\x61\x2c\x62\x29\x20\x7b\x20\x27\x62\x61\x72\x5c\x33\x36\x30\x5c\x32\x32\x30\x5c\x32\x32\x30\x5c\x32\x31\x34\x27\x3b\x20\x7d", "\x29\x28\x29\x3b",
      i::FUNCTION_SCOPE, i::SLOPPY },
    { NULL, NULL, NULL, i::EVAL_SCOPE, i::SLOPPY }
  };

  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();

  v8::HandleScope handles(CcTest::isolate());
  v8::Handle<v8::Context> context = v8::Context::New(CcTest::isolate());
  v8::Context::Scope context_scope(context);

  isolate->stack_guard()->SetStackLimit(GetCurrentStackPosition() - 128 * 1024);

  for (int i = 0; source_data[i].outer_prefix; i++) {
    int kPrefixLen = Utf8LengthHelper(source_data[i].outer_prefix);
    int kInnerLen = Utf8LengthHelper(source_data[i].inner_source);
    int kSuffixLen = Utf8LengthHelper(source_data[i].outer_suffix);
    int kPrefixByteLen = i::StrLength(source_data[i].outer_prefix);
    int kInnerByteLen = i::StrLength(source_data[i].inner_source);
    int kSuffixByteLen = i::StrLength(source_data[i].outer_suffix);
    int kProgramSize = kPrefixLen + kInnerLen + kSuffixLen;
    int kProgramByteSize = kPrefixByteLen + kInnerByteLen + kSuffixByteLen;
    i::ScopedVector<char> program(kProgramByteSize + 1);
    i::SNPrintF(program, "\x6c\xa2\x6c\xa2\x6c\xa2",
                         source_data[i].outer_prefix,
                         source_data[i].inner_source,
                         source_data[i].outer_suffix);

    // Parse program source.
    i::Handle<i::String> source = factory->NewStringFromUtf8(
        i::CStrVector(program.start())).ToHandleChecked();
    CHECK_EQ(source->length(), kProgramSize);
    i::Handle<i::Script> script = factory->NewScript(source);
    i::CompilationInfoWithZone info(script);
    i::Parser parser(&info);
    parser.set_allow_lazy(true);
    parser.set_allow_harmony_scoping(true);
    parser.set_allow_arrow_functions(true);
    info.MarkAsGlobal();
    info.SetStrictMode(source_data[i].strict_mode);
    parser.Parse();
    CHECK(info.function() != NULL);

    // Check scope types and positions.
    i::Scope* scope = info.function()->scope();
    CHECK(scope->is_global_scope());
    CHECK_EQ(scope->start_position(), 0);
    CHECK_EQ(scope->end_position(), kProgramSize);
    CHECK_EQ(scope->inner_scopes()->length(), 1);

    i::Scope* inner_scope = scope->inner_scopes()->at(0);
    CHECK_EQ(inner_scope->scope_type(), source_data[i].scope_type);
    CHECK_EQ(inner_scope->start_position(), kPrefixLen);
    // The end position of a token is one position after the last
    // character belonging to that token.
    CHECK_EQ(inner_scope->end_position(), kPrefixLen + kInnerLen);
  }
}


const char* ReadString(unsigned* start) {
  int length = start[0];
  char* result = i::NewArray<char>(length + 1);
  for (int i = 0; i < length; i++) {
    result[i] = start[i + 1];
  }
  result[length] = '\x0';
  return result;
}


i::Handle<i::String> FormatMessage(i::Vector<unsigned> data) {
  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();
  const char* message =
      ReadString(&data[i::PreparseDataConstants::kMessageTextPos]);
  i::Handle<i::String> format = v8::Utils::OpenHandle(
      *v8::String::NewFromUtf8(CcTest::isolate(), message));
  int arg_count = data[i::PreparseDataConstants::kMessageArgCountPos];
  const char* arg = NULL;
  i::Handle<i::JSArray> args_array;
  if (arg_count == 1) {
    // Position after text found by skipping past length field and
    // length field content words.
    int pos = i::PreparseDataConstants::kMessageTextPos + 1 +
              data[i::PreparseDataConstants::kMessageTextPos];
    arg = ReadString(&data[pos]);
    args_array = factory->NewJSArray(1);
    i::JSArray::SetElement(args_array, 0, v8::Utils::OpenHandle(*v8_str(arg)),
                           NONE, i::SLOPPY).Check();
  } else {
    CHECK_EQ(0, arg_count);
    args_array = factory->NewJSArray(0);
  }

  i::Handle<i::JSObject> builtins(isolate->js_builtins_object());
  i::Handle<i::Object> format_fun = i::Object::GetProperty(
      isolate, builtins, "\x46\x6f\x72\x6d\x61\x74\x4d\x65\x73\x73\x61\x67\x65").ToHandleChecked();
  i::Handle<i::Object> arg_handles[] = { format, args_array };
  i::Handle<i::Object> result = i::Execution::Call(
      isolate, format_fun, builtins, 2, arg_handles).ToHandleChecked();
  CHECK(result->IsString());
  i::DeleteArray(message);
  i::DeleteArray(arg);
  data.Dispose();
  return i::Handle<i::String>::cast(result);
}


enum ParserFlag {
  kAllowLazy,
  kAllowNativesSyntax,
  kAllowHarmonyScoping,
  kAllowModules,
  kAllowGenerators,
  kAllowHarmonyNumericLiterals,
  kAllowArrowFunctions
};


enum ParserSyncTestResult {
  kSuccessOrError,
  kSuccess,
  kError
};

template <typename Traits>
void SetParserFlags(i::ParserBase<Traits>* parser,
                    i::EnumSet<ParserFlag> flags) {
  parser->set_allow_lazy(flags.Contains(kAllowLazy));
  parser->set_allow_natives_syntax(flags.Contains(kAllowNativesSyntax));
  parser->set_allow_harmony_scoping(flags.Contains(kAllowHarmonyScoping));
  parser->set_allow_modules(flags.Contains(kAllowModules));
  parser->set_allow_generators(flags.Contains(kAllowGenerators));
  parser->set_allow_harmony_numeric_literals(
      flags.Contains(kAllowHarmonyNumericLiterals));
  parser->set_allow_arrow_functions(flags.Contains(kAllowArrowFunctions));
}


void TestParserSyncWithFlags(i::Handle<i::String> source,
                             i::EnumSet<ParserFlag> flags,
                             ParserSyncTestResult result) {
  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();

  uintptr_t stack_limit = isolate->stack_guard()->real_climit();

  // Preparse the data.
  i::CompleteParserRecorder log;
  {
    i::Scanner scanner(isolate->unicode_cache());
    i::GenericStringUtf16CharacterStream stream(source, 0, source->length());
    i::PreParser preparser(&scanner, &log, stack_limit);
    SetParserFlags(&preparser, flags);
    scanner.Initialize(&stream);
    i::PreParser::PreParseResult result = preparser.PreParseProgram();
    CHECK_EQ(i::PreParser::kPreParseSuccess, result);
  }

  bool preparse_error = log.HasError();

  // Parse the data
  i::FunctionLiteral* function;
  {
    i::Handle<i::Script> script = factory->NewScript(source);
    i::CompilationInfoWithZone info(script);
    i::Parser parser(&info);
    SetParserFlags(&parser, flags);
    info.MarkAsGlobal();
    parser.Parse();
    function = info.function();
  }

  // Check that preparsing fails iff parsing fails.
  if (function == NULL) {
    // Extract exception from the parser.
    CHECK(isolate->has_pending_exception());
    i::Handle<i::JSObject> exception_handle(
        i::JSObject::cast(isolate->pending_exception()));
    i::Handle<i::String> message_string =
        i::Handle<i::String>::cast(i::Object::GetProperty(
            isolate, exception_handle, "\x6d\x65\x73\x73\x61\x67\x65").ToHandleChecked());

    if (result == kSuccess) {
      v8::base::OS::Print(
          "\x50\x61\x72\x73\x65\x72\x20\x66\x61\x69\x6c\x65\x64\x20\x6f\x6e\x3a\xa"
          "\x9\x6c\xa2\xa"
          "\x77\x69\x74\x68\x20\x65\x72\x72\x6f\x72\x3a\xa"
          "\x9\x6c\xa2\xa"
          "\x48\x6f\x77\x65\x76\x65\x72\x2c\x20\x77\x65\x20\x65\x78\x70\x65\x63\x74\x65\x64\x20\x6e\x6f\x20\x65\x72\x72\x6f\x72\x2e",
          source->ToCString().get(), message_string->ToCString().get());
      CHECK(false);
    }

    if (!preparse_error) {
      v8::base::OS::Print(
          "\x50\x61\x72\x73\x65\x72\x20\x66\x61\x69\x6c\x65\x64\x20\x6f\x6e\x3a\xa"
          "\x9\x6c\xa2\xa"
          "\x77\x69\x74\x68\x20\x65\x72\x72\x6f\x72\x3a\xa"
          "\x9\x6c\xa2\xa"
          "\x48\x6f\x77\x65\x76\x65\x72\x2c\x20\x74\x68\x65\x20\x70\x72\x65\x70\x61\x72\x73\x65\x72\x20\x73\x75\x63\x63\x65\x65\x64\x65\x64",
          source->ToCString().get(), message_string->ToCString().get());
      CHECK(false);
    }
    // Check that preparser and parser produce the same error.
    i::Handle<i::String> preparser_message =
        FormatMessage(log.ErrorMessageData());
    if (!i::String::Equals(message_string, preparser_message)) {
      v8::base::OS::Print(
          "\x45\x78\x70\x65\x63\x74\x65\x64\x20\x70\x61\x72\x73\x65\x72\x20\x61\x6e\x64\x20\x70\x72\x65\x70\x61\x72\x73\x65\x72\x20\x74\x6f\x20\x70\x72\x6f\x64\x75\x63\x65\x20\x74\x68\x65\x20\x73\x61\x6d\x65\x20\x65\x72\x72\x6f\x72\x20\x6f\x6e\x3a\xa"
          "\x9\x6c\xa2\xa"
          "\x48\x6f\x77\x65\x76\x65\x72\x2c\x20\x66\x6f\x75\x6e\x64\x20\x74\x68\x65\x20\x66\x6f\x6c\x6c\x6f\x77\x69\x6e\x67\x20\x65\x72\x72\x6f\x72\x20\x6d\x65\x73\x73\x61\x67\x65\x73\xa"
          "\x9\x70\x61\x72\x73\x65\x72\x3a\x20\x20\x20\x20\x6c\xa2\xa"
          "\x9\x70\x72\x65\x70\x61\x72\x73\x65\x72\x3a\x20\x6c\xa2\xa",
          source->ToCString().get(),
          message_string->ToCString().get(),
          preparser_message->ToCString().get());
      CHECK(false);
    }
  } else if (preparse_error) {
    v8::base::OS::Print(
        "\x50\x72\x65\x70\x61\x72\x73\x65\x72\x20\x66\x61\x69\x6c\x65\x64\x20\x6f\x6e\x3a\xa"
        "\x9\x6c\xa2\xa"
        "\x77\x69\x74\x68\x20\x65\x72\x72\x6f\x72\x3a\xa"
        "\x9\x6c\xa2\xa"
        "\x48\x6f\x77\x65\x76\x65\x72\x2c\x20\x74\x68\x65\x20\x70\x61\x72\x73\x65\x72\x20\x73\x75\x63\x63\x65\x65\x64\x65\x64",
        source->ToCString().get(),
        FormatMessage(log.ErrorMessageData())->ToCString().get());
    CHECK(false);
  } else if (result == kError) {
    v8::base::OS::Print(
        "\x45\x78\x70\x65\x63\x74\x65\x64\x20\x65\x72\x72\x6f\x72\x20\x6f\x6e\x3a\xa"
        "\x9\x6c\xa2\xa"
        "\x48\x6f\x77\x65\x76\x65\x72\x2c\x20\x70\x61\x72\x73\x65\x72\x20\x61\x6e\x64\x20\x70\x72\x65\x70\x61\x72\x73\x65\x72\x20\x73\x75\x63\x63\x65\x65\x64\x65\x64",
        source->ToCString().get());
    CHECK(false);
  }
}


void TestParserSync(const char* source,
                    const ParserFlag* varying_flags,
                    size_t varying_flags_length,
                    ParserSyncTestResult result = kSuccessOrError,
                    const ParserFlag* always_true_flags = NULL,
                    size_t always_true_flags_length = 0) {
  i::Handle<i::String> str =
      CcTest::i_isolate()->factory()->NewStringFromAsciiChecked(source);
  for (int bits = 0; bits < (1 << varying_flags_length); bits++) {
    i::EnumSet<ParserFlag> flags;
    for (size_t flag_index = 0; flag_index < varying_flags_length;
         ++flag_index) {
      if ((bits & (1 << flag_index)) != 0) flags.Add(varying_flags[flag_index]);
    }
    for (size_t flag_index = 0; flag_index < always_true_flags_length;
         ++flag_index) {
      flags.Add(always_true_flags[flag_index]);
    }
    TestParserSyncWithFlags(str, flags, result);
  }
}


TEST(ParserSync) {
  const char* context_data[][2] = {
    { "", "" },
    { "\x7b", "\x7d" },
    { "\x69\x66\x20\x28\x74\x72\x75\x65\x29\x20", "\x20\x65\x6c\x73\x65\x20\x7b\x7d" },
    { "\x69\x66\x20\x28\x74\x72\x75\x65\x29\x20\x7b\x7d\x20\x65\x6c\x73\x65\x20", "" },
    { "\x69\x66\x20\x28\x74\x72\x75\x65\x29\x20", "" },
    { "\x64\x6f\x20", "\x20\x77\x68\x69\x6c\x65\x20\x28\x66\x61\x6c\x73\x65\x29" },
    { "\x77\x68\x69\x6c\x65\x20\x28\x66\x61\x6c\x73\x65\x29\x20", "" },
    { "\x66\x6f\x72\x20\x28\x3b\x3b\x29\x20", "" },
    { "\x77\x69\x74\x68\x20\x28\x7b\x7d\x29", "" },
    { "\x73\x77\x69\x74\x63\x68\x20\x28\x31\x32\x29\x20\x7b\x20\x63\x61\x73\x65\x20\x31\x32\x3a\x20", "\x7d" },
    { "\x73\x77\x69\x74\x63\x68\x20\x28\x31\x32\x29\x20\x7b\x20\x64\x65\x66\x61\x75\x6c\x74\x3a\x20", "\x7d" },
    { "\x73\x77\x69\x74\x63\x68\x20\x28\x31\x32\x29\x20\x7b\x20", "\x63\x61\x73\x65\x20\x31\x32\x3a\x20\x7d" },
    { "\x6c\x61\x62\x65\x6c\x32\x3a\x20", "" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x7b\x7d",
    "\x76\x61\x72\x20\x78",
    "\x76\x61\x72\x20\x78\x20\x3d\x20\x31",
    "\x63\x6f\x6e\x73\x74\x20\x78",
    "\x63\x6f\x6e\x73\x74\x20\x78\x20\x3d\x20\x31",
    "\x3b",
    "\x31\x32",
    "\x69\x66\x20\x28\x66\x61\x6c\x73\x65\x29\x20\x7b\x7d\x20\x65\x6c\x73\x65\x20\x3b",
    "\x69\x66\x20\x28\x66\x61\x6c\x73\x65\x29\x20\x7b\x7d\x20\x65\x6c\x73\x65\x20\x7b\x7d",
    "\x69\x66\x20\x28\x66\x61\x6c\x73\x65\x29\x20\x7b\x7d\x20\x65\x6c\x73\x65\x20\x31\x32",
    "\x69\x66\x20\x28\x66\x61\x6c\x73\x65\x29\x20\x3b"
    "\x69\x66\x20\x28\x66\x61\x6c\x73\x65\x29\x20\x7b\x7d",
    "\x69\x66\x20\x28\x66\x61\x6c\x73\x65\x29\x20\x31\x32",
    "\x64\x6f\x20\x7b\x7d\x20\x77\x68\x69\x6c\x65\x20\x28\x66\x61\x6c\x73\x65\x29",
    "\x66\x6f\x72\x20\x28\x3b\x3b\x29\x20\x3b",
    "\x66\x6f\x72\x20\x28\x3b\x3b\x29\x20\x7b\x7d",
    "\x66\x6f\x72\x20\x28\x3b\x3b\x29\x20\x31\x32",
    "\x63\x6f\x6e\x74\x69\x6e\x75\x65",
    "\x63\x6f\x6e\x74\x69\x6e\x75\x65\x20\x6c\x61\x62\x65\x6c",
    "\x63\x6f\x6e\x74\x69\x6e\x75\x65\xa\x6c\x61\x62\x65\x6c",
    "\x62\x72\x65\x61\x6b",
    "\x62\x72\x65\x61\x6b\x20\x6c\x61\x62\x65\x6c",
    "\x62\x72\x65\x61\x6b\xa\x6c\x61\x62\x65\x6c",
    // TODO(marja): activate once parsing 'return' is merged into ParserBase.
    // "return",
    // "return  12",
    // "return\n12",
    "\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x3b",
    "\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x7b\x7d",
    "\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x31\x32",
    "\x73\x77\x69\x74\x63\x68\x20\x28\x7b\x7d\x29\x20\x7b\x20\x64\x65\x66\x61\x75\x6c\x74\x3a\x20\x7d"
    "\x6c\x61\x62\x65\x6c\x33\x3a\x20"
    "\x74\x68\x72\x6f\x77",
    "\x74\x68\x72\x6f\x77\x20\x20\x31\x32",
    "\x74\x68\x72\x6f\x77\xa1\x32",
    "\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x28\x65\x29\x20\x7b\x7d",
    "\x74\x72\x79\x20\x7b\x7d\x20\x66\x69\x6e\x61\x6c\x6c\x79\x20\x7b\x7d",
    "\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x28\x65\x29\x20\x7b\x7d\x20\x66\x69\x6e\x61\x6c\x6c\x79\x20\x7b\x7d",
    "\x64\x65\x62\x75\x67\x67\x65\x72",
    NULL
  };

  const char* termination_data[] = {
    "",
    "\x3b",
    "\xa",
    "\x3b\xa",
    "\xa\x3b",
    NULL
  };

  v8::HandleScope handles(CcTest::isolate());
  v8::Handle<v8::Context> context = v8::Context::New(CcTest::isolate());
  v8::Context::Scope context_scope(context);

  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  static const ParserFlag flags1[] = {kAllowLazy, kAllowHarmonyScoping,
                                      kAllowModules, kAllowGenerators,
                                      kAllowArrowFunctions};
  for (int i = 0; context_data[i][0] != NULL; ++i) {
    for (int j = 0; statement_data[j] != NULL; ++j) {
      for (int k = 0; termination_data[k] != NULL; ++k) {
        int kPrefixLen = i::StrLength(context_data[i][0]);
        int kStatementLen = i::StrLength(statement_data[j]);
        int kTerminationLen = i::StrLength(termination_data[k]);
        int kSuffixLen = i::StrLength(context_data[i][1]);
        int kProgramSize = kPrefixLen + kStatementLen + kTerminationLen
            + kSuffixLen + i::StrLength("\x6c\x61\x62\x65\x6c\x3a\x20\x66\x6f\x72\x20\x28\x3b\x3b\x29\x20\x7b\x20\x20\x7d");

        // Plug the source code pieces together.
        i::ScopedVector<char> program(kProgramSize + 1);
        int length = i::SNPrintF(program,
            "\x6c\x61\x62\x65\x6c\x3a\x20\x66\x6f\x72\x20\x28\x3b\x3b\x29\x20\x7b\x20\x6c\xa2\x6c\xa2\x6c\xa2\x6c\xa2\x20\x7d",
            context_data[i][0],
            statement_data[j],
            termination_data[k],
            context_data[i][1]);
        CHECK(length == kProgramSize);
        TestParserSync(program.start(), flags1, ARRAY_SIZE(flags1));
      }
    }
  }

  // Neither Harmony numeric literals nor our natives syntax have any
  // interaction with the flags above, so test these separately to reduce
  // the combinatorial explosion.
  static const ParserFlag flags2[] = { kAllowHarmonyNumericLiterals };
  TestParserSync("\x30\x6f\x31\x32\x33\x34", flags2, ARRAY_SIZE(flags2));
  TestParserSync("\x30\x62\x31\x30\x31\x31", flags2, ARRAY_SIZE(flags2));

  static const ParserFlag flags3[] = { kAllowNativesSyntax };
  TestParserSync("\x25\x44\x65\x62\x75\x67\x50\x72\x69\x6e\x74\x28\x31\x32\x33\x29", flags3, ARRAY_SIZE(flags3));
}


TEST(StrictOctal) {
  // Test that syntax error caused by octal literal is reported correctly as
  // such (issue 2220).
  v8::V8::Initialize();
  v8::HandleScope scope(CcTest::isolate());
  v8::Context::Scope context_scope(
      v8::Context::New(CcTest::isolate()));
  v8::TryCatch try_catch;
  const char* script =
      "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x20\x20\x20\x20\x20\x20\xa"
      "\x61\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x20\x20\x20\x20\x20\x20\xa"
      "\x20\x20\x62\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x20\x20\x20\x20\xa"
      "\x20\x20\x20\x20\x30\x31\x3b\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\xa"
      "\x20\x20\x7d\x3b\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\xa"
      "\x7d\x3b\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\xa";
  v8::Script::Compile(v8::String::NewFromUtf8(CcTest::isolate(), script));
  CHECK(try_catch.HasCaught());
  v8::String::Utf8Value exception(try_catch.Exception());
  CHECK_EQ("\x53\x79\x6e\x74\x61\x78\x45\x72\x72\x6f\x72\x3a\x20\x4f\x63\x74\x61\x6c\x20\x6c\x69\x74\x65\x72\x61\x6c\x73\x20\x61\x72\x65\x20\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x77\x65\x64\x20\x69\x6e\x20\x73\x74\x72\x69\x63\x74\x20\x6d\x6f\x64\x65\x2e",
           *exception);
}


void RunParserSyncTest(const char* context_data[][2],
                       const char* statement_data[],
                       ParserSyncTestResult result,
                       const ParserFlag* flags = NULL,
                       int flags_len = 0,
                       const ParserFlag* always_true_flags = NULL,
                       int always_true_flags_len = 0) {
  v8::HandleScope handles(CcTest::isolate());
  v8::Handle<v8::Context> context = v8::Context::New(CcTest::isolate());
  v8::Context::Scope context_scope(context);

  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  static const ParserFlag default_flags[] = {
      kAllowLazy,       kAllowHarmonyScoping, kAllowModules,
      kAllowGenerators, kAllowNativesSyntax,  kAllowArrowFunctions};
  ParserFlag* generated_flags = NULL;
  if (flags == NULL) {
    flags = default_flags;
    flags_len = ARRAY_SIZE(default_flags);
    if (always_true_flags != NULL) {
      // Remove always_true_flags from default_flags.
      CHECK(always_true_flags_len < flags_len);
      generated_flags = new ParserFlag[flags_len - always_true_flags_len];
      int flag_index = 0;
      for (int i = 0; i < flags_len; ++i) {
        bool use_flag = true;
        for (int j = 0; j < always_true_flags_len; ++j) {
          if (flags[i] == always_true_flags[j]) {
            use_flag = false;
            break;
          }
        }
        if (use_flag) generated_flags[flag_index++] = flags[i];
      }
      CHECK(flag_index == flags_len - always_true_flags_len);
      flags_len = flag_index;
      flags = generated_flags;
    }
  }
  for (int i = 0; context_data[i][0] != NULL; ++i) {
    for (int j = 0; statement_data[j] != NULL; ++j) {
      int kPrefixLen = i::StrLength(context_data[i][0]);
      int kStatementLen = i::StrLength(statement_data[j]);
      int kSuffixLen = i::StrLength(context_data[i][1]);
      int kProgramSize = kPrefixLen + kStatementLen + kSuffixLen;

      // Plug the source code pieces together.
      i::ScopedVector<char> program(kProgramSize + 1);
      int length = i::SNPrintF(program,
                               "\x6c\xa2\x6c\xa2\x6c\xa2",
                               context_data[i][0],
                               statement_data[j],
                               context_data[i][1]);
      CHECK(length == kProgramSize);
      TestParserSync(program.start(),
                     flags,
                     flags_len,
                     result,
                     always_true_flags,
                     always_true_flags_len);
    }
  }
  delete[] generated_flags;
}


TEST(ErrorsEvalAndArguments) {
  // Tests that both preparsing and parsing produce the right kind of errors for
  // using "eval" and "arguments" as identifiers. Without the strict mode, it's
  // ok to use "eval" or "arguments" as identifiers. With the strict mode, it
  // isn't.
  const char* context_data[][2] = {
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "" },
    { "\x76\x61\x72\x20\x65\x76\x61\x6c\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d"},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x65\x76\x61\x6c\x3b",
    "\x76\x61\x72\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x65\x76\x61\x6c\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x65\x76\x61\x6c\x29\x20\x7b\x20\x7d",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x65\x76\x61\x6c\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x65\x76\x61\x6c\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x65\x76\x61\x6c\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b\x20\x7d",
    "\x28\x65\x76\x61\x6c\x29\x20\x3d\x3e\x20\x7b\x20\x7d",
    "\x28\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x3d\x3e\x20\x7b\x20\x7d",
    "\x28\x66\x6f\x6f\x2c\x20\x65\x76\x61\x6c\x29\x20\x3d\x3e\x20\x7b\x20\x7d",
    "\x28\x66\x6f\x6f\x2c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x3d\x3e\x20\x7b\x20\x7d",
    "\x65\x76\x61\x6c\x20\x3d\x20\x31\x3b",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x65\x76\x61\x6c\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x3d\x20\x31\x3b",
    "\x2b\x2b\x65\x76\x61\x6c\x3b",
    "\x2b\x2b\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b",
    "\x65\x76\x61\x6c\x2b\x2b\x3b",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x2b\x2b\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsEvalAndArgumentsSloppy) {
  // Tests that both preparsing and parsing accept "eval" and "arguments" as
  // identifiers when needed.
  const char* context_data[][2] = {
    { "", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b", "\x7d"},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x65\x76\x61\x6c\x3b",
    "\x76\x61\x72\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x65\x76\x61\x6c\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x65\x76\x61\x6c\x29\x20\x7b\x20\x7d",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x65\x76\x61\x6c\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x65\x76\x61\x6c\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x65\x76\x61\x6c\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b\x20\x7d",
    "\x65\x76\x61\x6c\x20\x3d\x20\x31\x3b",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x65\x76\x61\x6c\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x3d\x20\x31\x3b",
    "\x2b\x2b\x65\x76\x61\x6c\x3b",
    "\x2b\x2b\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b",
    "\x65\x76\x61\x6c\x2b\x2b\x3b",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x2b\x2b\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(NoErrorsEvalAndArgumentsStrict) {
  const char* context_data[][2] = {
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b\x20\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "\x7d" },
    { "\x28\x29\x20\x3d\x3e\x20\x7b\x20\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x65\x76\x61\x6c\x3b",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x65\x76\x61\x6c\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x20\x65\x76\x61\x6c\x3a\x20\x31\x20\x7d\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3a\x20\x31\x20\x7d\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x20\x7d\x3b\x20\x66\x6f\x6f\x2e\x65\x76\x61\x6c\x20\x3d\x20\x7b\x7d\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x20\x7d\x3b\x20\x66\x6f\x6f\x2e\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x3d\x20\x7b\x7d\x3b",
    NULL
  };

  static const ParserFlag always_flags[] = {kAllowArrowFunctions};
  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_flags, ARRAY_SIZE(always_flags));
}


TEST(ErrorsFutureStrictReservedWords) {
  // Tests that both preparsing and parsing produce the right kind of errors for
  // using future strict reserved words as identifiers. Without the strict mode,
  // it's ok to use future strict reserved words as identifiers. With the strict
  // mode, it isn't.
  const char* context_data[][2] = {
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d"},
    { "\x28\x29\x20\x3d\x3e\x20\x7b\x20\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b\x20\x7d",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x3d\x20\x31\x3b",
    "\x2b\x2b\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x2b\x2b\x3b",
    "\x76\x61\x72\x20\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x33\x3b",
    NULL
  };

  static const ParserFlag always_flags[] = {kAllowArrowFunctions};
  RunParserSyncTest(context_data, statement_data, kError, NULL, 0, always_flags,
                    ARRAY_SIZE(always_flags));
}


TEST(NoErrorsFutureStrictReservedWords) {
  const char* context_data[][2] = {
    { "", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b", "\x7d"},
    { "\x28\x29\x20\x3d\x3e\x20\x7b", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b\x20\x7d",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x3d\x20\x31\x3b",
    "\x2b\x2b\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x2b\x2b\x3b",
    "\x76\x61\x72\x20\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x33\x3b",
    NULL
  };

  static const ParserFlag always_flags[] = {kAllowArrowFunctions};
  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_flags, ARRAY_SIZE(always_flags));
}


TEST(ErrorsReservedWords) {
  // Tests that both preparsing and parsing produce the right kind of errors for
  // using future reserved words as identifiers. These tests don't depend on the
  // strict mode.
  const char* context_data[][2] = {
    { "", "" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "" },
    { "\x76\x61\x72\x20\x65\x76\x61\x6c\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b", "\x7d"},
    { "\x76\x61\x72\x20\x65\x76\x61\x6c\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d"},
    { "\x76\x61\x72\x20\x65\x76\x61\x6c\x3b\x20\x28\x29\x20\x3d\x3e\x20\x7b", "\x7d"},
    { "\x76\x61\x72\x20\x65\x76\x61\x6c\x3b\x20\x28\x29\x20\x3d\x3e\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d"},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x73\x75\x70\x65\x72\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x73\x75\x70\x65\x72\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x73\x75\x70\x65\x72\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x75\x70\x65\x72\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x73\x75\x70\x65\x72\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x73\x75\x70\x65\x72\x29\x20\x7b\x20\x7d",
    "\x28\x73\x75\x70\x65\x72\x29\x20\x3d\x3e\x20\x7b\x20\x7d",
    "\x28\x62\x61\x72\x2c\x20\x73\x75\x70\x65\x72\x29\x20\x3d\x3e\x20\x7b\x20\x7d",
    "\x73\x75\x70\x65\x72\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x73\x75\x70\x65\x72\x20\x3d\x20\x31\x3b",
    "\x2b\x2b\x73\x75\x70\x65\x72\x3b",
    "\x73\x75\x70\x65\x72\x2b\x2b\x3b",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x20\x73\x75\x70\x65\x72",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsLetSloppyAllModes) {
  // In sloppy mode, it's okay to use "let" as identifier.
  const char* context_data[][2] = {
    { "", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x28\x29\x20\x7b", "\x7d" },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x28\x29\x20\x7b", "\x7d\x29" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x6c\x65\x74\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x6c\x65\x74\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x6c\x65\x74\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6c\x65\x74\x28\x29\x20\x7b\x20\x7d",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6c\x65\x74\x28\x29\x20\x7b\x20\x7d\x29",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x6c\x65\x74\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x6c\x65\x74\x29\x20\x7b\x20\x7d",
    "\x6c\x65\x74\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x6c\x65\x74\x20\x3d\x20\x31\x3b",
    "\x6c\x65\x74\x20\x2a\x20\x32\x3b",
    "\x2b\x2b\x6c\x65\x74\x3b",
    "\x6c\x65\x74\x2b\x2b\x3b",
    "\x6c\x65\x74\x3a\x20\x33\x34",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6c\x65\x74\x28\x6c\x65\x74\x29\x20\x7b\x20\x6c\x65\x74\x3a\x20\x6c\x65\x74\x28\x6c\x65\x74\x20\x2b\x20\x6c\x65\x74\x28\x30\x29\x29\x3b\x20\x7d",
    "\x28\x7b\x20\x6c\x65\x74\x3a\x20\x31\x20\x7d\x29",
    "\x28\x7b\x20\x67\x65\x74\x20\x6c\x65\x74\x28\x29\x20\x7b\x20\x31\x20\x7d\x20\x7d\x29",
    "\x6c\x65\x74\x28\x31\x30\x30\x29",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(NoErrorsYieldSloppyAllModes) {
  // In sloppy mode, it's okay to use "yield" as identifier, *except* inside a
  // generator (see other test).
  const char* context_data[][2] = {
    { "", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d" },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x29" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x79\x69\x65\x6c\x64\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x79\x69\x65\x6c\x64\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x29",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x32\x3b",
    "\x2b\x2b\x79\x69\x65\x6c\x64\x3b",
    "\x79\x69\x65\x6c\x64\x2b\x2b\x3b",
    "\x79\x69\x65\x6c\x64\x3a\x20\x33\x34",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x79\x69\x65\x6c\x64\x20\x28\x79\x69\x65\x6c\x64\x20\x2b\x20\x79\x69\x65\x6c\x64\x28\x30\x29\x29\x3b\x20\x7d",
    "\x28\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x31\x20\x7d\x29",
    "\x28\x7b\x20\x67\x65\x74\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x31\x20\x7d\x20\x7d\x29",
    "\x79\x69\x65\x6c\x64\x28\x31\x30\x30\x29",
    "\x79\x69\x65\x6c\x64\x5b\x31\x30\x30\x5d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(NoErrorsYieldSloppyGeneratorsEnabled) {
  // In sloppy mode, it's okay to use "yield" as identifier, *except* inside a
  // generator (see next test).
  const char* context_data[][2] = {
    { "", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x20\x7d" },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x29" },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x29\x20\x7d\x29" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x79\x69\x65\x6c\x64\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x79\x69\x65\x6c\x64\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x29",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x29",
    "\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x32\x3b",
    "\x2b\x2b\x79\x69\x65\x6c\x64\x3b",
    "\x79\x69\x65\x6c\x64\x2b\x2b\x3b",
    "\x79\x69\x65\x6c\x64\x3a\x20\x33\x34",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x79\x69\x65\x6c\x64\x20\x28\x79\x69\x65\x6c\x64\x20\x2b\x20\x79\x69\x65\x6c\x64\x28\x30\x29\x29\x3b\x20\x7d",
    "\x28\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x31\x20\x7d\x29",
    "\x28\x7b\x20\x67\x65\x74\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x31\x20\x7d\x20\x7d\x29",
    "\x79\x69\x65\x6c\x64\x28\x31\x30\x30\x29",
    "\x79\x69\x65\x6c\x64\x5b\x31\x30\x30\x5d",
    NULL
  };

  // This test requires kAllowGenerators to succeed.
  static const ParserFlag always_true_flags[] = { kAllowGenerators };
  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_true_flags, 1);
}


TEST(ErrorsYieldStrict) {
  const char* context_data[][2] = {
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d"},
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x20\x7d" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x29" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x29\x20\x7d\x29" },
    { "\x28\x29\x20\x3d\x3e\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x79\x69\x65\x6c\x64\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x79\x69\x65\x6c\x64\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x29",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x29",
    "\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x2b\x2b\x79\x69\x65\x6c\x64\x3b",
    "\x79\x69\x65\x6c\x64\x2b\x2b\x3b",
    "\x79\x69\x65\x6c\x64\x3a\x20\x33\x34\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsGenerator) {
  const char* context_data[][2] = {
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b", "\x7d" },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b", "\x7d\x29" },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x28\x29\x20\x7b", "\x7d\x29" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    // A generator without a body is valid.
    ""
    // Valid yield expressions inside generators.
    "\x79\x69\x65\x6c\x64\x20\x32\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x32\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\xa\x20\x32\x3b",
    "\x79\x69\x65\x6c\x64\x20\x79\x69\x65\x6c\x64\x20\x31\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x79\x69\x65\x6c\x64\x20\x2a\x20\x31\x3b",
    "\x79\x69\x65\x6c\x64\x20\x33\x20\x2b\x20\x28\x79\x69\x65\x6c\x64\x20\x34\x29\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x33\x20\x2b\x20\x28\x79\x69\x65\x6c\x64\x20\x2a\x20\x34\x29\x3b",
    "\x28\x79\x69\x65\x6c\x64\x20\x2a\x20\x33\x29\x20\x2b\x20\x28\x79\x69\x65\x6c\x64\x20\x2a\x20\x34\x29\x3b",
    "\x79\x69\x65\x6c\x64\x20\x33\x3b\x20\x79\x69\x65\x6c\x64\x20\x34\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x33\x3b\x20\x79\x69\x65\x6c\x64\x20\x2a\x20\x34\x3b",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d\x29",
    "\x79\x69\x65\x6c\x64\x20\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x31\x32\x20\x7d",
    "\x79\x69\x65\x6c\x64\x20\x2f\x2a\x20\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f\x20\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x31\x32\x20\x7d",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\xa\x20\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x31\x32\x20\x7d",
    "\x79\x69\x65\x6c\x64\x20\x2f\x2a\x20\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f\x20\x2a\x20\xa\x20\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x31\x32\x20\x7d",
    // You can return in a generator.
    "\x79\x69\x65\x6c\x64\x20\x31\x3b\x20\x72\x65\x74\x75\x72\x6e",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x31\x3b\x20\x72\x65\x74\x75\x72\x6e",
    "\x79\x69\x65\x6c\x64\x20\x31\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x33\x37",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x31\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x33\x37",
    "\x79\x69\x65\x6c\x64\x20\x31\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x33\x37\x3b\x20\x79\x69\x65\x6c\x64\x20\x27\x64\x65\x61\x64\x27\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a\x20\x31\x3b\x20\x72\x65\x74\x75\x72\x6e\x20\x33\x37\x3b\x20\x79\x69\x65\x6c\x64\x20\x2a\x20\x27\x64\x65\x61\x64\x27\x3b",
    // Yield is still a valid key in object literals.
    "\x28\x7b\x20\x79\x69\x65\x6c\x64\x3a\x20\x31\x20\x7d\x29",
    "\x28\x7b\x20\x67\x65\x74\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x20\x7d\x29",
    // Yield without RHS.
    "\x79\x69\x65\x6c\x64\x3b",
    "\x79\x69\x65\x6c\x64",
    "\x79\x69\x65\x6c\x64\xa",
    "\x79\x69\x65\x6c\x64\x20\x2f\x2a\x20\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f"
    "\x79\x69\x65\x6c\x64\x20\x2f\x2f\x20\x63\x6f\x6d\x6d\x65\x6e\x74\xa"
    "\x28\x79\x69\x65\x6c\x64\x29",
    "\x5b\x79\x69\x65\x6c\x64\x5d",
    "\x7b\x79\x69\x65\x6c\x64\x7d",
    "\x79\x69\x65\x6c\x64\x2c\x20\x79\x69\x65\x6c\x64",
    "\x79\x69\x65\x6c\x64\x3b\x20\x79\x69\x65\x6c\x64",
    "\x28\x79\x69\x65\x6c\x64\x29\x20\x3f\x20\x79\x69\x65\x6c\x64\x20\x3a\x20\x79\x69\x65\x6c\x64",
    "\x28\x79\x69\x65\x6c\x64\x29\x20\xa\x20\x3f\x20\x79\x69\x65\x6c\x64\x20\x3a\x20\x79\x69\x65\x6c\x64",
    // If there is a newline before the next token, we don't look for RHS.
    "\x79\x69\x65\x6c\x64\xaf\x6f\x72\x20\x28\x3b\x3b\x29\x20\x7b\x7d",
    NULL
  };

  // This test requires kAllowGenerators to succeed.
  static const ParserFlag always_true_flags[] = {
    kAllowGenerators
  };
  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_true_flags, 1);
}


TEST(ErrorsYieldGenerator) {
  const char* context_data[][2] = {
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b", "\x7d" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x67\x65\x6e\x28\x29\x20\x7b", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    // Invalid yield expressions inside generators.
    "\x76\x61\x72\x20\x79\x69\x65\x6c\x64\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x2c\x20\x79\x69\x65\x6c\x64\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    // The name of the NFE is let-bound in the generator, which does not permit
    // yield to be an identifier.
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x29",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d\x29",
    // Yield isn't valid as a formal parameter for generators.
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x66\x6f\x6f\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d",
    "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20\x66\x6f\x6f\x28\x79\x69\x65\x6c\x64\x29\x20\x7b\x20\x7d\x29",
    "\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x79\x69\x65\x6c\x64\x20\x3d\x20\x31\x3b",
    "\x2b\x2b\x79\x69\x65\x6c\x64\x3b",
    "\x79\x69\x65\x6c\x64\x2b\x2b\x3b",
    "\x79\x69\x65\x6c\x64\x20\x2a",
    "\x28\x79\x69\x65\x6c\x64\x20\x2a\x29",
    // Yield binds very loosely, so this parses as "yield (3 + yield 4)", which
    // is invalid.
    "\x79\x69\x65\x6c\x64\x20\x33\x20\x2b\x20\x79\x69\x65\x6c\x64\x20\x34\x3b",
    "\x79\x69\x65\x6c\x64\x3a\x20\x33\x34",
    "\x79\x69\x65\x6c\x64\x20\x3f\x20\x31\x20\x3a\x20\x32",
    // Parses as yield (/ yield): invalid.
    "\x79\x69\x65\x6c\x64\x20\x2f\x20\x79\x69\x65\x6c\x64",
    "\x2b\x20\x79\x69\x65\x6c\x64",
    "\x2b\x20\x79\x69\x65\x6c\x64\x20\x33",
    // Invalid (no newline allowed between yield and *).
    "\x79\x69\x65\x6c\x64\xa\x2a\x33",
    // Invalid (we see a newline, so we parse {yield:42} as a statement, not an
    // object literal, and yield is not a valid label).
    "\x79\x69\x65\x6c\x64\xa\x7b\x79\x69\x65\x6c\x64\x3a\x20\x34\x32\x7d",
    "\x79\x69\x65\x6c\x64\x20\x2f\x2a\x20\x63\x6f\x6d\x6d\x65\x6e\x74\x20\x2a\x2f\xa\x20\x7b\x79\x69\x65\x6c\x64\x3a\x20\x34\x32\x7d",
    "\x79\x69\x65\x6c\x64\x20\x2f\x2f\x63\x6f\x6d\x6d\x65\x6e\x74\xa\x20\x7b\x79\x69\x65\x6c\x64\x3a\x20\x34\x32\x7d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(ErrorsNameOfStrictFunction) {
  // Tests that illegal tokens as names of a strict function produce the correct
  // errors.
  const char* context_data[][2] = {
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20", ""},
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e", ""},
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20", ""},
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x65\x76\x61\x6c\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x7d",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x7d",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x7d",
    "\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x7d",
    // Future reserved words are always illegal
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x75\x70\x65\x72\x28\x29\x20\x7b\x20\x7d",
    "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x75\x70\x65\x72\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x7d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsNameOfStrictFunction) {
  const char* context_data[][2] = {
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x65\x76\x61\x6c\x28\x29\x20\x7b\x20\x7d",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x28\x29\x20\x7b\x20\x7d",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x28\x29\x20\x7b\x20\x7d",
    "\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(NoErrorsNameOfStrictGenerator) {
  const char* context_data[][2] = {
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x2a\x20", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x65\x76\x61\x6c\x28\x29\x20\x7b\x20\x7d",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x28\x29\x20\x7b\x20\x7d",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x28\x29\x20\x7b\x20\x7d",
    "\x79\x69\x65\x6c\x64\x28\x29\x20\x7b\x20\x7d",
    NULL
  };

  // This test requires kAllowGenerators to succeed.
  static const ParserFlag always_true_flags[] = {
    kAllowGenerators
  };
  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_true_flags, 1);
}


TEST(ErrorsIllegalWordsAsLabelsSloppy) {
  // Using future reserved words as labels is always an error.
  const char* context_data[][2] = {
    { "", ""},
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b", "\x7d" },
    { "\x28\x29\x20\x3d\x3e\x20\x7b", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x73\x75\x70\x65\x72\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x73\x75\x70\x65\x72\x3b\x20\x7d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(ErrorsIllegalWordsAsLabelsStrict) {
  // Tests that illegal tokens as labels produce the correct errors.
  const char* context_data[][2] = {
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "" },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d"},
    { "\x28\x29\x20\x3d\x3e\x20\x7b\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x73\x75\x70\x65\x72\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x73\x75\x70\x65\x72\x3b\x20\x7d",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b\x20\x7d",
    "\x79\x69\x65\x6c\x64\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x79\x69\x65\x6c\x64\x3b\x20\x7d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsIllegalWordsAsLabels) {
  // Using eval and arguments as labels is legal even in strict mode.
  const char* context_data[][2] = {
    { "", ""},
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b", "\x7d" },
    { "\x28\x29\x20\x3d\x3e\x20\x7b", "\x7d" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", "" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b", "\x7d" },
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x28\x29\x20\x3d\x3e\x20\x7b", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x6d\x79\x6c\x61\x62\x65\x6c\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x6d\x79\x6c\x61\x62\x65\x6c\x3b\x20\x7d",
    "\x65\x76\x61\x6c\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x65\x76\x61\x6c\x3b\x20\x7d",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b\x20\x7d",
    NULL
  };

  static const ParserFlag always_flags[] = {kAllowArrowFunctions};
  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_flags, ARRAY_SIZE(always_flags));
}


TEST(ErrorsParenthesizedLabels) {
  // Parenthesized identifiers shouldn't be recognized as labels.
  const char* context_data[][2] = {
    { "", ""},
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x65\x73\x74\x5f\x66\x75\x6e\x63\x28\x29\x20\x7b", "\x7d" },
    { "\x28\x29\x20\x3d\x3e\x20\x7b", "\x7d" },
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x28\x6d\x79\x6c\x61\x62\x65\x6c\x29\x3a\x20\x77\x68\x69\x6c\x65\x28\x74\x72\x75\x65\x29\x20\x7b\x20\x62\x72\x65\x61\x6b\x20\x6d\x79\x6c\x61\x62\x65\x6c\x3b\x20\x7d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsParenthesizedDirectivePrologue) {
  // Parenthesized directive prologue shouldn't be recognized.
  const char* context_data[][2] = {
    { "", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x28\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x29\x3b\x20\x76\x61\x72\x20\x65\x76\x61\x6c\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(ErrorsNotAnIdentifierName) {
  const char* context_data[][2] = {
    { "", ""},
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x7b\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x7d\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x3d\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x38\x38\x38\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x2d\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x2d\x2d\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsIdentifierNames) {
  // Keywords etc. are valid as property names.
  const char* context_data[][2] = {
    { "", ""},
    { "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x69\x66\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x79\x69\x65\x6c\x64\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x73\x75\x70\x65\x72\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x65\x76\x61\x6c\x3b",
    "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x7b\x7d\x3b\x20\x66\x6f\x6f\x2e\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(DontRegressPreParserDataSizes) {
  // These tests make sure that Parser doesn't start producing less "preparse
  // data" (data which the embedder can cache).
  v8::V8::Initialize();
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope handles(isolate);

  CcTest::i_isolate()->stack_guard()->SetStackLimit(GetCurrentStackPosition() -
                                                    128 * 1024);

  struct TestCase {
    const char* program;
    int functions;
  } test_cases[] = {
    // No functions.
    {"\x76\x61\x72\x20\x78\x20\x3d\x20\x34\x32\x3b", 0},
    // Functions.
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x29\x20\x7b\x7d", 1}, {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x29\x20\x7b\x7d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x62\x61\x72\x28\x29\x20\x7b\x7d", 2},
    // Getter / setter functions are recorded as functions if they're on the top
    // level.
    {"\x76\x61\x72\x20\x78\x20\x3d\x20\x7b\x67\x65\x74\x20\x66\x6f\x6f\x28\x29\x7b\x7d\x20\x7d\x3b", 1},
    // Functions insize lazy functions are not recorded.
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6c\x61\x7a\x79\x28\x29\x20\x7b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x28\x29\x20\x7b\x7d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x62\x28\x29\x20\x7b\x7d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x63\x28\x29\x20\x7b\x7d\x20\x7d", 1},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6c\x61\x7a\x79\x28\x29\x20\x7b\x20\x76\x61\x72\x20\x78\x20\x3d\x20\x7b\x67\x65\x74\x20\x66\x6f\x6f\x28\x29\x7b\x7d\x20\x7d\x20\x7d", 1},
    {NULL, 0}
  };

  for (int i = 0; test_cases[i].program; i++) {
    const char* program = test_cases[i].program;
    i::Factory* factory = CcTest::i_isolate()->factory();
    i::Handle<i::String> source =
        factory->NewStringFromUtf8(i::CStrVector(program)).ToHandleChecked();
    i::Handle<i::Script> script = factory->NewScript(source);
    i::CompilationInfoWithZone info(script);
    i::ScriptData* sd = NULL;
    info.SetCachedData(&sd, v8::ScriptCompiler::kProduceParserCache);
    i::Parser::Parse(&info, true);
    i::ParseData pd(sd);

    if (pd.FunctionCount() != test_cases[i].functions) {
      v8::base::OS::Print(
          "\x45\x78\x70\x65\x63\x74\x65\x64\x20\x70\x72\x65\x70\x61\x72\x73\x65\x20\x64\x61\x74\x61\x20\x66\x6f\x72\x20\x70\x72\x6f\x67\x72\x61\x6d\x3a\xa"
          "\x9\x6c\xa2\xa"
          "\x74\x6f\x20\x63\x6f\x6e\x74\x61\x69\x6e\x20\x6c\x84\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x73\x2c\x20\x68\x6f\x77\x65\x76\x65\x72\x2c\x20\x72\x65\x63\x65\x69\x76\x65\x64\x20\x6c\x84\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x73\x2e\xa",
          program, test_cases[i].functions, pd.FunctionCount());
      CHECK(false);
    }
    delete sd;
  }
}


TEST(FunctionDeclaresItselfStrict) {
  // Tests that we produce the right kinds of errors when a function declares
  // itself strict (we cannot produce there errors as soon as we see the
  // offending identifiers, because we don't know at that point whether the
  // function is strict or not).
  const char* context_data[][2] = {
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x65\x76\x61\x6c\x28\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x28\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x79\x69\x65\x6c\x64\x28\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x28\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x65\x76\x61\x6c\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x79\x69\x65\x6c\x64\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x65\x76\x61\x6c\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x79\x69\x65\x6c\x64\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x7b", "\x7d"},
    {"\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x28\x62\x61\x72\x2c\x20\x62\x61\x72\x29\x20\x7b", "\x7d"},
    { NULL, NULL }
  };

  const char* strict_statement_data[] = {
    "\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b",
    NULL
  };

  const char* non_strict_statement_data[] = {
    "\x3b",
    NULL
  };

  RunParserSyncTest(context_data, strict_statement_data, kError);
  RunParserSyncTest(context_data, non_strict_statement_data, kSuccess);
}


TEST(ErrorsTryWithoutCatchOrFinally) {
  const char* context_data[][2] = {
    {"", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x74\x72\x79\x20\x7b\x20\x7d",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x66\x6f\x6f\x28\x29\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x65\x29\x20\x66\x6f\x6f\x28\x29\x3b",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x7b\x20\x7d",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x66\x69\x6e\x61\x6c\x6c\x79\x20\x66\x6f\x6f\x28\x29\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsTryCatchFinally) {
  const char* context_data[][2] = {
    {"", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x65\x29\x20\x7b\x20\x7d",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x65\x29\x20\x7b\x20\x7d\x20\x66\x69\x6e\x61\x6c\x6c\x79\x20\x7b\x20\x7d",
    "\x74\x72\x79\x20\x7b\x20\x7d\x20\x66\x69\x6e\x61\x6c\x6c\x79\x20\x7b\x20\x7d",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(ErrorsRegexpLiteral) {
  const char* context_data[][2] = {
    {"\x76\x61\x72\x20\x72\x20\x3d\x20", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x2f\x75\x6e\x74\x65\x72\x6d\x69\x6e\x61\x74\x65\x64",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsRegexpLiteral) {
  const char* context_data[][2] = {
    {"\x76\x61\x72\x20\x72\x20\x3d\x20", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x2f\x66\x6f\x6f\x2f",
    "\x2f\x66\x6f\x6f\x2f\x67",
    "\x2f\x66\x6f\x6f\x2f\x77\x68\x61\x74\x65\x76\x65\x72",  // This is an error but not detected by the parser.
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(Intrinsics) {
  const char* context_data[][2] = {
    {"", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x6c\xa2\x96\x6d\x65\x69\x6e\x74\x72\x69\x6e\x73\x69\x63\x28\x61\x72\x67\x29",
    NULL
  };

  // This test requires kAllowNativesSyntax to succeed.
  static const ParserFlag always_true_flags[] = {
    kAllowNativesSyntax
  };

  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_true_flags, 1);
}


TEST(NoErrorsNewExpression) {
  const char* context_data[][2] = {
    {"", ""},
    {"\x76\x61\x72\x20\x66\x20\x3d", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x6e\x65\x77\x20\x66\x6f\x6f",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x28\x31\x29\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x28\x31\x2c\x20\x32\x29\x3b",
    // The first () will be processed as a part of the NewExpression and the
    // second () will be processed as part of LeftHandSideExpression.
    "\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x28\x29\x3b",
    // The first () will be processed as a part of the inner NewExpression and
    // the second () will be processed as a part of the outer NewExpression.
    "\x6e\x65\x77\x20\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x28\x29\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x2e\x62\x61\x72\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x2e\x62\x61\x72\x28\x29\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x2e\x62\x61\x72\x2e\x62\x61\x7a\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x2e\x62\x61\x72\x28\x29\x2e\x62\x61\x7a\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x5b\x62\x61\x72\x5d\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x5b\x62\x61\x72\x5d\x28\x29\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x5b\x62\x61\x72\x5d\x5b\x62\x61\x7a\x5d\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x5b\x62\x61\x72\x5d\x28\x29\x5b\x62\x61\x7a\x5d\x3b",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x5b\x62\x61\x72\x5d\x2e\x62\x61\x7a\x28\x62\x61\x7a\x29\x28\x29\x5b\x62\x61\x72\x5d\x2e\x62\x61\x7a\x3b",
    "\x6e\x65\x77\x20\x22\x66\x6f\x6f\x22",  // Runtime error
    "\x6e\x65\x77\x20\x31",  // Runtime error
    // This even runs:
    "\x28\x6e\x65\x77\x20\x6e\x65\x77\x20\x46\x75\x6e\x63\x74\x69\x6f\x6e\x28\x22\x74\x68\x69\x73\x2e\x78\x20\x3d\x20\x31\x22\x29\x29\x2e\x78\x3b",
    "\x6e\x65\x77\x20\x6e\x65\x77\x20\x54\x65\x73\x74\x5f\x54\x77\x6f\x28\x53\x74\x72\x69\x6e\x67\x2c\x20\x32\x29\x2e\x76\x28\x30\x31\x32\x33\x29\x2e\x6c\x65\x6e\x67\x74\x68\x3b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(ErrorsNewExpression) {
  const char* context_data[][2] = {
    {"", ""},
    {"\x76\x61\x72\x20\x66\x20\x3d", ""},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x6e\x65\x77\x20\x66\x6f\x6f\x20\x62\x61\x72",
    "\x6e\x65\x77\x20\x29\x20\x66\x6f\x6f",
    "\x6e\x65\x77\x20\x2b\x2b\x66\x6f\x6f",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x20\x2b\x2b",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(StrictObjectLiteralChecking) {
  const char* strict_context_data[][2] = {
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x7d\x3b"},
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x2c\x7d\x3b"},
    { NULL, NULL }
  };
  const char* non_strict_context_data[][2] = {
    {"\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x7d\x3b"},
    {"\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x2c\x7d\x3b"},
    { NULL, NULL }
  };

  // These are only errors in strict mode.
  const char* statement_data[] = {
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x66\x6f\x6f\x3a\x20\x32",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x22\x66\x6f\x6f\x22\x3a\x20\x32",
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x22\x66\x6f\x6f\x22\x3a\x20\x32",
    "\x31\x3a\x20\x31\x2c\x20\x31\x3a\x20\x32",
    "\x31\x3a\x20\x31\x2c\x20\x22\x31\x22\x3a\x20\x32",
    "\x67\x65\x74\x3a\x20\x31\x2c\x20\x67\x65\x74\x3a\x20\x32",  // Not a getter for real, just a property called get.
    "\x73\x65\x74\x3a\x20\x31\x2c\x20\x73\x65\x74\x3a\x20\x32",  // Not a setter for real, just a property called set.
    NULL
  };

  RunParserSyncTest(non_strict_context_data, statement_data, kSuccess);
  RunParserSyncTest(strict_context_data, statement_data, kError);
}


TEST(ErrorsObjectLiteralChecking) {
  const char* context_data[][2] = {
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x7d\x3b"},
    {"\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x7d\x3b"},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x2c",
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x66\x6f\x6f\x28\x29\x20\x7b\x7d",
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x66\x6f\x6f\x28\x76\x29\x20\x7b\x7d",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x22\x66\x6f\x6f\x22\x28\x29\x20\x7b\x7d",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x22\x66\x6f\x6f\x22\x28\x76\x29\x20\x7b\x7d",
    "\x31\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x31\x28\x29\x20\x7b\x7d",
    "\x31\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x31\x28\x29\x20\x7b\x7d",
    // It's counter-intuitive, but these collide too (even in classic
    // mode). Note that we can have "foo" and foo as properties in classic mode,
    // but we cannot have "foo" and get foo, or foo and get "foo".
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x22\x66\x6f\x6f\x22\x28\x29\x20\x7b\x7d",
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x22\x66\x6f\x6f\x22\x28\x76\x29\x20\x7b\x7d",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x66\x6f\x6f\x28\x29\x20\x7b\x7d",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x66\x6f\x6f\x28\x76\x29\x20\x7b\x7d",
    "\x31\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x22\x31\x22\x28\x29\x20\x7b\x7d",
    "\x31\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x22\x31\x22\x28\x29\x20\x7b\x7d",
    "\x22\x31\x22\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x31\x28\x29\x20\x7b\x7d"
    "\x22\x31\x22\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x31\x28\x76\x29\x20\x7b\x7d"
    // Wrong number of parameters
    "\x67\x65\x74\x20\x62\x61\x72\x28\x78\x29\x20\x7b\x7d",
    "\x67\x65\x74\x20\x62\x61\x72\x28\x78\x2c\x20\x79\x29\x20\x7b\x7d",
    "\x73\x65\x74\x20\x62\x61\x72\x28\x29\x20\x7b\x7d",
    "\x73\x65\x74\x20\x62\x61\x72\x28\x78\x2c\x20\x79\x29\x20\x7b\x7d",
    // Parsing FunctionLiteral for getter or setter fails
    "\x67\x65\x74\x20\x66\x6f\x6f\x28\x20\x2b",
    "\x67\x65\x74\x20\x66\x6f\x6f\x28\x29\x20\x22\x65\x72\x72\x6f\x72\x22",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kError);
}


TEST(NoErrorsObjectLiteralChecking) {
  const char* context_data[][2] = {
    {"\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x7d\x3b"},
    {"\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x2c\x7d\x3b"},
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x7d\x3b"},
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x76\x61\x72\x20\x6d\x79\x6f\x62\x6a\x65\x63\x74\x20\x3d\x20\x7b", "\x2c\x7d\x3b"},
    { NULL, NULL }
  };

  const char* statement_data[] = {
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x62\x61\x72\x3a\x20\x32",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x22\x62\x61\x72\x22\x3a\x20\x32",
    "\x31\x3a\x20\x31\x2c\x20\x32\x3a\x20\x32",
    // Syntax: IdentifierName ':' AssignmentExpression
    "\x66\x6f\x6f\x3a\x20\x62\x61\x72\x20\x3d\x20\x35\x20\x2b\x20\x62\x61\x7a",
    // Syntax: 'get' PropertyName '(' ')' '{' FunctionBody '}'
    "\x67\x65\x74\x20\x66\x6f\x6f\x28\x29\x20\x7b\x7d",
    "\x67\x65\x74\x20\x22\x66\x6f\x6f\x22\x28\x29\x20\x7b\x7d",
    "\x67\x65\x74\x20\x31\x28\x29\x20\x7b\x7d",
    // Syntax: 'set' PropertyName '(' PropertySetParameterList ')'
    //     '{' FunctionBody '}'
    "\x73\x65\x74\x20\x66\x6f\x6f\x28\x76\x29\x20\x7b\x7d",
    "\x73\x65\x74\x20\x22\x66\x6f\x6f\x22\x28\x76\x29\x20\x7b\x7d",
    "\x73\x65\x74\x20\x31\x28\x76\x29\x20\x7b\x7d",
    // Non-colliding getters and setters -> no errors
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x62\x61\x72\x28\x29\x20\x7b\x7d",
    "\x66\x6f\x6f\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x62\x61\x72\x28\x76\x29\x20\x7b\x7d",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x22\x62\x61\x72\x22\x28\x29\x20\x7b\x7d",
    "\x22\x66\x6f\x6f\x22\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x22\x62\x61\x72\x22\x28\x76\x29\x20\x7b\x7d",
    "\x31\x3a\x20\x31\x2c\x20\x67\x65\x74\x20\x32\x28\x29\x20\x7b\x7d",
    "\x31\x3a\x20\x31\x2c\x20\x73\x65\x74\x20\x32\x28\x76\x29\x20\x7b\x7d",
    // Keywords, future reserved and strict future reserved are also allowed as
    // property names.
    "\x69\x66\x3a\x20\x34",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3a\x20\x35",
    "\x73\x75\x70\x65\x72\x3a\x20\x36",
    "\x65\x76\x61\x6c\x3a\x20\x37",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3a\x20\x38",
    NULL
  };

  RunParserSyncTest(context_data, statement_data, kSuccess);
}


TEST(TooManyArguments) {
  const char* context_data[][2] = {
    {"\x66\x6f\x6f\x28", "\x30\x29"},
    { NULL, NULL }
  };

  using v8::internal::Code;
  char statement[Code::kMaxArguments * 2 + 1];
  for (int i = 0; i < Code::kMaxArguments; ++i) {
    statement[2 * i] = '\x30';
    statement[2 * i + 1] = '\x2c';
  }
  statement[Code::kMaxArguments * 2] = 0;

  const char* statement_data[] = {
    statement,
    NULL
  };

  // The test is quite slow, so run it with a reduced set of flags.
  static const ParserFlag empty_flags[] = {kAllowLazy};
  RunParserSyncTest(context_data, statement_data, kError, empty_flags, 1);
}


TEST(StrictDelete) {
  // "delete <Identifier>" is not allowed in strict mode.
  const char* strict_context_data[][2] = {
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", ""},
    { NULL, NULL }
  };

  const char* sloppy_context_data[][2] = {
    {"", ""},
    { NULL, NULL }
  };

  // These are errors in the strict mode.
  const char* sloppy_statement_data[] = {
    "\x64\x65\x6c\x65\x74\x65\x20\x66\x6f\x6f\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x66\x6f\x6f\x20\x2b\x20\x31\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x28\x66\x6f\x6f\x29\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x65\x76\x61\x6c\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x3b",
    NULL
  };

  // These are always OK
  const char* good_statement_data[] = {
    "\x64\x65\x6c\x65\x74\x65\x20\x74\x68\x69\x73\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x31\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x31\x20\x2b\x20\x32\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x66\x6f\x6f\x28\x29\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x66\x6f\x6f\x2e\x62\x61\x72\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x66\x6f\x6f\x5b\x62\x61\x72\x5d\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x66\x6f\x6f\x2d\x2d\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x2d\x2d\x66\x6f\x6f\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x3b",
    "\x64\x65\x6c\x65\x74\x65\x20\x6e\x65\x77\x20\x66\x6f\x6f\x28\x62\x61\x72\x29\x3b",
    NULL
  };

  // These are always errors
  const char* bad_statement_data[] = {
    "\x64\x65\x6c\x65\x74\x65\x20\x69\x66\x3b",
    NULL
  };

  RunParserSyncTest(strict_context_data, sloppy_statement_data, kError);
  RunParserSyncTest(sloppy_context_data, sloppy_statement_data, kSuccess);

  RunParserSyncTest(strict_context_data, good_statement_data, kSuccess);
  RunParserSyncTest(sloppy_context_data, good_statement_data, kSuccess);

  RunParserSyncTest(strict_context_data, bad_statement_data, kError);
  RunParserSyncTest(sloppy_context_data, bad_statement_data, kError);
}


TEST(InvalidLeftHandSide) {
  const char* assignment_context_data[][2] = {
    {"", "\x20\x3d\x20\x31\x3b"},
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x20\x3d\x20\x31\x3b"},
    { NULL, NULL }
  };

  const char* prefix_context_data[][2] = {
    {"\x2b\x2b", "\x3b"},
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20\x2b\x2b", "\x3b"},
    {NULL, NULL},
  };

  const char* postfix_context_data[][2] = {
    {"", "\x2b\x2b\x3b"},
    {"\x22\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x22\x3b\x20", "\x2b\x2b\x3b"},
    { NULL, NULL }
  };

  // Good left hand sides for assigment or prefix / postfix operations.
  const char* good_statement_data[] = {
    "\x66\x6f\x6f",
    "\x66\x6f\x6f\x2e\x62\x61\x72",
    "\x66\x6f\x6f\x5b\x62\x61\x72\x5d",
    "\x66\x6f\x6f\x28\x29\x5b\x62\x61\x72\x5d",
    "\x66\x6f\x6f\x28\x29\x2e\x62\x61\x72",
    "\x74\x68\x69\x73\x2e\x66\x6f\x6f",
    "\x74\x68\x69\x73\x5b\x66\x6f\x6f\x5d",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x5b\x62\x61\x72\x5d",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x2e\x62\x61\x72",
    "\x66\x6f\x6f\x28\x29",
    "\x66\x6f\x6f\x28\x62\x61\x72\x29",
    "\x66\x6f\x6f\x5b\x62\x61\x72\x5d\x28\x29",
    "\x66\x6f\x6f\x2e\x62\x61\x72\x28\x29",
    "\x74\x68\x69\x73\x28\x29",
    "\x74\x68\x69\x73\x2e\x66\x6f\x6f\x28\x29",
    "\x74\x68\x69\x73\x5b\x66\x6f\x6f\x5d\x2e\x62\x61\x72\x28\x29",
    "\x74\x68\x69\x73\x2e\x66\x6f\x6f\x5b\x66\x6f\x6f\x5d\x2e\x62\x61\x72\x28\x74\x68\x69\x73\x29\x28\x62\x61\x72\x29\x5b\x66\x6f\x6f\x5d\x28\x29",
    NULL
  };

  // Bad left hand sides for assigment or prefix / postfix operations.
  const char* bad_statement_data_common[] = {
    "\x32",
    "\x6e\x65\x77\x20\x66\x6f\x6f",
    "\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29",
    "\x6e\x75\x6c\x6c",
    "\x69\x66",  // Unexpected token
    "\x7b\x78\x3a\x20\x31\x7d",  // Unexpected token
    "\x74\x68\x69\x73",
    "\x22\x62\x61\x72\x22",
    "\x28\x66\x6f\x6f\x20\x2b\x20\x62\x61\x72\x29",
    "\x6e\x65\x77\x20\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x5b\x62\x61\x72\x5d",  // means: new (new foo()[bar])
    "\x6e\x65\x77\x20\x6e\x65\x77\x20\x66\x6f\x6f\x28\x29\x2e\x62\x61\x72",  // means: new (new foo()[bar])
    NULL
  };

  // These are not okay for assignment, but okay for prefix / postix.
  const char* bad_statement_data_for_assignment[] = {
    "\x2b\x2b\x66\x6f\x6f",
    "\x66\x6f\x6f\x2b\x2b",
    "\x66\x6f\x6f\x20\x2b\x20\x62\x61\x72",
    NULL
  };

  RunParserSyncTest(assignment_context_data, good_statement_data, kSuccess);
  RunParserSyncTest(assignment_context_data, bad_statement_data_common, kError);
  RunParserSyncTest(assignment_context_data, bad_statement_data_for_assignment,
                    kError);

  RunParserSyncTest(prefix_context_data, good_statement_data, kSuccess);
  RunParserSyncTest(prefix_context_data, bad_statement_data_common, kError);

  RunParserSyncTest(postfix_context_data, good_statement_data, kSuccess);
  RunParserSyncTest(postfix_context_data, bad_statement_data_common, kError);
}


TEST(FuncNameInferrerBasic) {
  // Tests that function names are inferred properly.
  i::FLAG_allow_natives_syntax = true;
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope scope(isolate);
  LocalContext env;
  CompileRun("\x76\x61\x72\x20\x66\x6f\x6f\x31\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x3b\x20"
             "\x76\x61\x72\x20\x66\x6f\x6f\x32\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x33\x28\x29\x20\x7b\x7d\x3b\x20"
             "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x5f\x63\x74\x6f\x72\x28\x29\x20\x7b\x20"
             "\x20\x20\x76\x61\x72\x20\x66\x6f\x6f\x34\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x3b\x20"
             "\x20\x20\x72\x65\x74\x75\x72\x6e\x20\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x66\x6f\x6f\x34\x29\x3b\x20"
             "\x7d\x20"
             "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x43\x74\x6f\x72\x28\x29\x20\x7b\x20"
             "\x20\x20\x76\x61\x72\x20\x66\x6f\x6f\x35\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x3b\x20"
             "\x20\x20\x72\x65\x74\x75\x72\x6e\x20\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x66\x6f\x6f\x35\x29\x3b\x20"
             "\x7d\x20"
             "\x76\x61\x72\x20\x6f\x62\x6a\x31\x20\x3d\x20\x7b\x20\x66\x6f\x6f\x36\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x20\x7d\x3b\x20"
             "\x76\x61\x72\x20\x6f\x62\x6a\x32\x20\x3d\x20\x7b\x20\x27\x66\x6f\x6f\x37\x27\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x20\x7d\x3b\x20"
             "\x76\x61\x72\x20\x6f\x62\x6a\x33\x20\x3d\x20\x7b\x7d\x3b\x20"
             "\x6f\x62\x6a\x33\x5b\x31\x5d\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x3b\x20"
             "\x76\x61\x72\x20\x6f\x62\x6a\x34\x20\x3d\x20\x7b\x7d\x3b\x20"
             "\x6f\x62\x6a\x34\x5b\x31\x5d\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x6f\x6f\x38\x28\x29\x20\x7b\x7d\x3b\x20"
             "\x76\x61\x72\x20\x6f\x62\x6a\x35\x20\x3d\x20\x7b\x7d\x3b\x20"
             "\x6f\x62\x6a\x35\x5b\x27\x66\x6f\x6f\x39\x27\x5d\x20\x3d\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x3b\x20"
             "\x76\x61\x72\x20\x6f\x62\x6a\x36\x20\x3d\x20\x7b\x20\x6f\x62\x6a\x37\x20\x3a\x20\x7b\x20\x66\x6f\x6f\x31\x30\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x20\x7d\x20\x7d\x3b");
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x66\x6f\x6f\x31\x29", "\x66\x6f\x6f\x31");
  // foo2 is not unnamed -> its name is not inferred.
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x66\x6f\x6f\x32\x29", "");
  ExpectString("\x6e\x6f\x74\x5f\x63\x74\x6f\x72\x28\x29", "\x66\x6f\x6f\x34");
  ExpectString("\x43\x74\x6f\x72\x28\x29", "\x43\x74\x6f\x72\x2e\x66\x6f\x6f\x35");
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x31\x2e\x66\x6f\x6f\x36\x29", "\x6f\x62\x6a\x31\x2e\x66\x6f\x6f\x36");
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x32\x2e\x66\x6f\x6f\x37\x29", "\x6f\x62\x6a\x32\x2e\x66\x6f\x6f\x37");
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x33\x5b\x31\x5d\x29",
               "\x6f\x62\x6a\x33\x2e\x28\x61\x6e\x6f\x6e\x79\x6d\x6f\x75\x73\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x29");
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x34\x5b\x31\x5d\x29", "");
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x35\x5b\x27\x66\x6f\x6f\x39\x27\x5d\x29", "\x6f\x62\x6a\x35\x2e\x66\x6f\x6f\x39");
  ExpectString("\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x36\x2e\x6f\x62\x6a\x37\x2e\x66\x6f\x6f\x31\x30\x29", "\x6f\x62\x6a\x36\x2e\x6f\x62\x6a\x37\x2e\x66\x6f\x6f\x31\x30");
}


TEST(FuncNameInferrerTwoByte) {
  // Tests function name inferring in cases where some parts of the inferred
  // function name are two-byte strings.
  i::FLAG_allow_natives_syntax = true;
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope scope(isolate);
  LocalContext env;
  uint16_t* two_byte_source = AsciiToTwoByteString(
      "\x76\x61\x72\x20\x6f\x62\x6a\x31\x20\x3d\x20\x7b\x20\x6f\x58\x6a\x32\x20\x3a\x20\x7b\x20\x66\x6f\x6f\x31\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x20\x7d\x20\x7d\x3b\x20"
      "\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x31\x2e\x6f\x58\x6a\x32\x2e\x66\x6f\x6f\x31\x29");
  uint16_t* two_byte_name = AsciiToTwoByteString("\x6f\x62\x6a\x31\x2e\x6f\x58\x6a\x32\x2e\x66\x6f\x6f\x31");
  // Make it really non-ASCII (replace the Xs with a non-ASCII character).
  two_byte_source[14] = two_byte_source[78] = two_byte_name[6] = 0x010d;
  v8::Local<v8::String> source =
      v8::String::NewFromTwoByte(isolate, two_byte_source);
  v8::Local<v8::Value> result = CompileRun(source);
  CHECK(result->IsString());
  v8::Local<v8::String> expected_name =
      v8::String::NewFromTwoByte(isolate, two_byte_name);
  CHECK(result->Equals(expected_name));
  i::DeleteArray(two_byte_source);
  i::DeleteArray(two_byte_name);
}


TEST(FuncNameInferrerEscaped) {
  // The same as FuncNameInferrerTwoByte, except that we express the two-byte
  // character as a unicode escape.
  i::FLAG_allow_natives_syntax = true;
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope scope(isolate);
  LocalContext env;
  uint16_t* two_byte_source = AsciiToTwoByteString(
      "\x76\x61\x72\x20\x6f\x62\x6a\x31\x20\x3d\x20\x7b\x20\x6f\x5c\x75\x30\x31\x30\x64\x6a\x32\x20\x3a\x20\x7b\x20\x66\x6f\x6f\x31\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x7d\x20\x7d\x20\x7d\x3b\x20"
      "\x6c\xc6\xa4\x95\x83\x74\x69\x6f\x6e\x47\x65\x74\x49\x6e\x66\x65\x72\x72\x65\x64\x4e\x61\x6d\x65\x28\x6f\x62\x6a\x31\x2e\x6f\x5c\x75\x30\x31\x30\x64\x6a\x32\x2e\x66\x6f\x6f\x31\x29");
  uint16_t* two_byte_name = AsciiToTwoByteString("\x6f\x62\x6a\x31\x2e\x6f\x58\x6a\x32\x2e\x66\x6f\x6f\x31");
  // Fix to correspond to the non-ASCII name in two_byte_source.
  two_byte_name[6] = 0x010d;
  v8::Local<v8::String> source =
      v8::String::NewFromTwoByte(isolate, two_byte_source);
  v8::Local<v8::Value> result = CompileRun(source);
  CHECK(result->IsString());
  v8::Local<v8::String> expected_name =
      v8::String::NewFromTwoByte(isolate, two_byte_name);
  CHECK(result->Equals(expected_name));
  i::DeleteArray(two_byte_source);
  i::DeleteArray(two_byte_name);
}


TEST(RegressionLazyFunctionWithErrorWithArg) {
  // The bug occurred when a lazy function had an error which requires a
  // parameter (such as "unknown label" here). The error message was processed
  // before the AstValueFactory containing the error message string was
  // internalized.
  v8::Isolate* isolate = CcTest::isolate();
  v8::HandleScope scope(isolate);
  LocalContext env;
  i::FLAG_lazy = true;
  i::FLAG_min_preparse_length = 0;
  CompileRun("\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x74\x68\x69\x73\x5f\x69\x73\x5f\x6c\x61\x7a\x79\x28\x29\x20\x7b\xa"
             "\x20\x20\x62\x72\x65\x61\x6b\x20\x70\x3b\xa"
             "\x7d\xa"
             "\x74\x68\x69\x73\x5f\x69\x73\x5f\x6c\x61\x7a\x79\x28\x29\x3b\xa");
}


TEST(SerializationOfMaybeAssignmentFlag) {
  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();
  i::HandleScope scope(isolate);
  LocalContext env;

  const char* src =
      "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x68\x28\x29\x20\x7b"
      "\x20\x20\x76\x61\x72\x20\x72\x65\x73\x75\x6c\x74\x20\x3d\x20\x5b\x5d\x3b"
      "\x20\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x28\x29\x20\x7b"
      "\x20\x20\x20\x20\x72\x65\x73\x75\x6c\x74\x2e\x70\x75\x73\x68\x28\x32\x29\x3b"
      "\x20\x20\x7d"
      "\x20\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x73\x73\x65\x72\x74\x52\x65\x73\x75\x6c\x74\x28\x72\x29\x20\x7b"
      "\x20\x20\x20\x20\x66\x28\x29\x3b"
      "\x20\x20\x20\x20\x72\x65\x73\x75\x6c\x74\x20\x3d\x20\x5b\x5d\x3b"
      "\x20\x20\x7d"
      "\x20\x20\x61\x73\x73\x65\x72\x74\x52\x65\x73\x75\x6c\x74\x28\x5b\x32\x5d\x29\x3b"
      "\x20\x20\x61\x73\x73\x65\x72\x74\x52\x65\x73\x75\x6c\x74\x28\x5b\x32\x5d\x29\x3b"
      "\x20\x20\x72\x65\x74\x75\x72\x6e\x20\x66\x3b"
      "\x7d\x3b"
      "\x68\x28\x29\x3b";

  i::ScopedVector<char> program(Utf8LengthHelper(src) + 1);
  i::SNPrintF(program, "\x6c\xa2", src);
  i::Handle<i::String> source = factory->InternalizeUtf8String(program.start());
  source->PrintOn(stdout);
  printf("\xa");
  i::Zone zone(isolate);
  v8::Local<v8::Value> v = CompileRun(src);
  i::Handle<i::Object> o = v8::Utils::OpenHandle(*v);
  i::Handle<i::JSFunction> f = i::Handle<i::JSFunction>::cast(o);
  i::Context* context = f->context();
  i::AstValueFactory avf(&zone, isolate->heap()->HashSeed());
  avf.Internalize(isolate);
  const i::AstRawString* name = avf.GetOneByteString("\x72\x65\x73\x75\x6c\x74");
  i::Handle<i::String> str = name->string();
  CHECK(str->IsInternalizedString());
  i::Scope* global_scope =
      new (&zone) i::Scope(NULL, i::GLOBAL_SCOPE, &avf, &zone);
  global_scope->Initialize();
  i::Scope* s = i::Scope::DeserializeScopeChain(context, global_scope, &zone);
  DCHECK(s != global_scope);
  DCHECK(name != NULL);

  // Get result from h's function context (that is f's context)
  i::Variable* var = s->Lookup(name);

  CHECK(var != NULL);
  // Maybe assigned should survive deserialization
  CHECK(var->maybe_assigned() == i::kMaybeAssigned);
  // TODO(sigurds) Figure out if is_used should survive context serialization.
}


TEST(IfArgumentsArrayAccessedThenParametersMaybeAssigned) {
  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();
  i::HandleScope scope(isolate);
  LocalContext env;


  const char* src =
      "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x28\x78\x29\x20\x7b"
      "\x20\x20\x20\x20\x76\x61\x72\x20\x61\x20\x3d\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x3b"
      "\x20\x20\x20\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x67\x28\x69\x29\x20\x7b"
      "\x20\x20\x20\x20\x20\x20\x2b\x2b\x61\x5b\x30\x5d\x3b"
      "\x20\x20\x20\x20\x7d\x3b"
      "\x20\x20\x20\x20\x72\x65\x74\x75\x72\x6e\x20\x67\x3b"
      "\x20\x20\x7d"
      "\x66\x28\x30\x29\x3b";

  i::ScopedVector<char> program(Utf8LengthHelper(src) + 1);
  i::SNPrintF(program, "\x6c\xa2", src);
  i::Handle<i::String> source = factory->InternalizeUtf8String(program.start());
  source->PrintOn(stdout);
  printf("\xa");
  i::Zone zone(isolate);
  v8::Local<v8::Value> v = CompileRun(src);
  i::Handle<i::Object> o = v8::Utils::OpenHandle(*v);
  i::Handle<i::JSFunction> f = i::Handle<i::JSFunction>::cast(o);
  i::Context* context = f->context();
  i::AstValueFactory avf(&zone, isolate->heap()->HashSeed());
  avf.Internalize(isolate);

  i::Scope* global_scope =
      new (&zone) i::Scope(NULL, i::GLOBAL_SCOPE, &avf, &zone);
  global_scope->Initialize();
  i::Scope* s = i::Scope::DeserializeScopeChain(context, global_scope, &zone);
  DCHECK(s != global_scope);
  const i::AstRawString* name_x = avf.GetOneByteString("\x78");

  // Get result from f's function context (that is g's outer context)
  i::Variable* var_x = s->Lookup(name_x);
  CHECK(var_x != NULL);
  CHECK(var_x->maybe_assigned() == i::kMaybeAssigned);
}


TEST(ExportsMaybeAssigned) {
  i::FLAG_use_strict = true;
  i::FLAG_harmony_scoping = true;
  i::FLAG_harmony_modules = true;

  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();
  i::HandleScope scope(isolate);
  LocalContext env;

  const char* src =
      "\x6d\x6f\x64\x75\x6c\x65\x20\x41\x20\x7b"
      "\x20\x20\x65\x78\x70\x6f\x72\x74\x20\x76\x61\x72\x20\x78\x20\x3d\x20\x31\x3b"
      "\x20\x20\x65\x78\x70\x6f\x72\x74\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x28\x29\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x78\x20\x7d\x3b"
      "\x20\x20\x65\x78\x70\x6f\x72\x74\x20\x63\x6f\x6e\x73\x74\x20\x79\x20\x3d\x20\x32\x3b"
      "\x20\x20\x6d\x6f\x64\x75\x6c\x65\x20\x42\x20\x7b\x7d"
      "\x20\x20\x65\x78\x70\x6f\x72\x74\x20\x6d\x6f\x64\x75\x6c\x65\x20\x43\x20\x7b\x7d"
      "\x7d\x3b"
      "\x41\x2e\x66";

  i::ScopedVector<char> program(Utf8LengthHelper(src) + 1);
  i::SNPrintF(program, "\x6c\xa2", src);
  i::Handle<i::String> source = factory->InternalizeUtf8String(program.start());
  source->PrintOn(stdout);
  printf("\xa");
  i::Zone zone(isolate);
  v8::Local<v8::Value> v = CompileRun(src);
  i::Handle<i::Object> o = v8::Utils::OpenHandle(*v);
  i::Handle<i::JSFunction> f = i::Handle<i::JSFunction>::cast(o);
  i::Context* context = f->context();
  i::AstValueFactory avf(&zone, isolate->heap()->HashSeed());
  avf.Internalize(isolate);

  i::Scope* global_scope =
      new (&zone) i::Scope(NULL, i::GLOBAL_SCOPE, &avf, &zone);
  global_scope->Initialize();
  i::Scope* s = i::Scope::DeserializeScopeChain(context, global_scope, &zone);
  DCHECK(s != global_scope);
  const i::AstRawString* name_x = avf.GetOneByteString("\x78");
  const i::AstRawString* name_f = avf.GetOneByteString("\x66");
  const i::AstRawString* name_y = avf.GetOneByteString("\x79");
  const i::AstRawString* name_B = avf.GetOneByteString("\x42");
  const i::AstRawString* name_C = avf.GetOneByteString("\x43");

  // Get result from h's function context (that is f's context)
  i::Variable* var_x = s->Lookup(name_x);
  CHECK(var_x != NULL);
  CHECK(var_x->maybe_assigned() == i::kMaybeAssigned);
  i::Variable* var_f = s->Lookup(name_f);
  CHECK(var_f != NULL);
  CHECK(var_f->maybe_assigned() == i::kMaybeAssigned);
  i::Variable* var_y = s->Lookup(name_y);
  CHECK(var_y != NULL);
  CHECK(var_y->maybe_assigned() == i::kNotAssigned);
  i::Variable* var_B = s->Lookup(name_B);
  CHECK(var_B != NULL);
  CHECK(var_B->maybe_assigned() == i::kNotAssigned);
  i::Variable* var_C = s->Lookup(name_C);
  CHECK(var_C != NULL);
  CHECK(var_C->maybe_assigned() == i::kNotAssigned);
}


TEST(InnerAssignment) {
  i::Isolate* isolate = CcTest::i_isolate();
  i::Factory* factory = isolate->factory();
  i::HandleScope scope(isolate);
  LocalContext env;

  const char* prefix = "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x66\x28\x29\x20\x7b";
  const char* midfix = "\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x67\x28\x29\x20\x7b";
  const char* suffix = "\x7d\x7d";
  struct { const char* source; bool assigned; bool strict; } outers[] = {
    // Actual assignments.
    { "\x76\x61\x72\x20\x78\x3b\x20\x76\x61\x72\x20\x78\x20\x3d\x20\x35\x3b", true, false },
    { "\x76\x61\x72\x20\x78\x3b\x20\x7b\x20\x76\x61\x72\x20\x78\x20\x3d\x20\x35\x3b\x20\x7d", true, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x3b\x20\x78\x20\x3d\x20\x36\x3b", true, true },
    { "\x76\x61\x72\x20\x78\x20\x3d\x20\x35\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x7d", true, false },
    // Actual non-assignments.
    { "\x76\x61\x72\x20\x78\x3b", false, false },
    { "\x76\x61\x72\x20\x78\x20\x3d\x20\x35\x3b", false, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x3b", false, true },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x20\x3d\x20\x36\x3b", false, true },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x76\x61\x72\x20\x78\x20\x3d\x20\x30\x3b\x20\x7b\x20\x6c\x65\x74\x20\x78\x20\x3d\x20\x36\x3b\x20\x7d", false, true },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x76\x61\x72\x20\x78\x20\x3d\x20\x30\x3b\x20\x7b\x20\x6c\x65\x74\x20\x78\x3b\x20\x78\x20\x3d\x20\x36\x3b\x20\x7d", false, true },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x20\x3d\x20\x30\x3b\x20\x7b\x20\x6c\x65\x74\x20\x78\x20\x3d\x20\x36\x3b\x20\x7d", false, true },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x20\x3d\x20\x30\x3b\x20\x7b\x20\x6c\x65\x74\x20\x78\x3b\x20\x78\x20\x3d\x20\x36\x3b\x20\x7d", false, true },
    { "\x76\x61\x72\x20\x78\x3b\x20\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x78\x29\x20\x7b\x20\x78\x20\x3d\x20\x35\x3b\x20\x7d", false, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x7d", false, false },
    // Eval approximation.
    { "\x76\x61\x72\x20\x78\x3b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b", true, false },
    { "\x65\x76\x61\x6c\x28\x27\x27\x29\x3b\x20\x76\x61\x72\x20\x78\x3b", true, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x3b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b", true, true },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b\x20\x6c\x65\x74\x20\x78\x3b", true, true },
    // Non-assignments not recognized, because the analysis is approximative.
    { "\x76\x61\x72\x20\x78\x3b\x20\x76\x61\x72\x20\x78\x3b", true, false },
    { "\x76\x61\x72\x20\x78\x20\x3d\x20\x35\x3b\x20\x76\x61\x72\x20\x78\x3b", true, false },
    { "\x76\x61\x72\x20\x78\x3b\x20\x7b\x20\x76\x61\x72\x20\x78\x3b\x20\x7d", true, false },
    { "\x76\x61\x72\x20\x78\x3b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x7d", true, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x7d\x3b\x20\x76\x61\x72\x20\x78\x3b", true, false },
    { "\x76\x61\x72\x20\x78\x3b\x20\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x20\x28\x78\x29\x20\x7b\x20\x76\x61\x72\x20\x78\x20\x3d\x20\x35\x3b\x20\x7d", true, false },
  };
  struct { const char* source; bool assigned; bool with; } inners[] = {
    // Actual assignments.
    { "\x78\x20\x3d\x20\x31\x3b", true, false },
    { "\x78\x2b\x2b\x3b", true, false },
    { "\x2b\x2b\x78\x3b", true, false },
    { "\x78\x2d\x2d\x3b", true, false },
    { "\x2d\x2d\x78\x3b", true, false },
    { "\x7b\x20\x78\x20\x3d\x20\x31\x3b\x20\x7d", true, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x7b\x20\x6c\x65\x74\x20\x78\x3b\x20\x7d\x3b\x20\x78\x20\x3d\x20\x30\x3b", true, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x7b\x20\x63\x6f\x6e\x73\x74\x20\x78\x20\x3d\x20\x31\x3b\x20\x7d\x3b\x20\x78\x20\x3d\x20\x30\x3b", true, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x7b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x7d\x20\x7d\x3b\x20\x78\x20\x3d\x20\x30\x3b", true, false },
    { "\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x7b\x20\x78\x20\x3d\x20\x31\x3b\x20\x7d", true, true },
    { "\x65\x76\x61\x6c\x28\x27\x27\x29\x3b", true, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x7b\x20\x6c\x65\x74\x20\x79\x3b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x20\x7d", true, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x68\x28\x29\x20\x7b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d", true, false },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d\x29", true, false },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d\x29", true, false },
    { "\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d\x29", true, true },
    // Actual non-assignments.
    { "", false, false },
    { "\x78\x3b", false, false },
    { "\x76\x61\x72\x20\x78\x3b", false, false },
    { "\x76\x61\x72\x20\x78\x20\x3d\x20\x38\x3b", false, false },
    { "\x76\x61\x72\x20\x78\x3b\x20\x78\x20\x3d\x20\x38\x3b", false, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x3b", false, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x20\x3d\x20\x38\x3b", false, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x3b\x20\x78\x20\x3d\x20\x38\x3b", false, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x63\x6f\x6e\x73\x74\x20\x78\x20\x3d\x20\x38\x3b", false, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x7d", false, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d", false, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x68\x28\x78\x29\x20\x7b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d", false, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x7b\x20\x6c\x65\x74\x20\x78\x3b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d", false, false },
    { "\x7b\x20\x76\x61\x72\x20\x78\x3b\x20\x7d\x3b\x20\x78\x20\x3d\x20\x30\x3b", false, false },
    { "\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x7b\x7d", false, true },
    { "\x76\x61\x72\x20\x78\x3b\x20\x7b\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x7b\x20\x78\x20\x3d\x20\x31\x3b\x20\x7d\x20\x7d", false, true },
    { "\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x28\x78\x29\x20\x7b\x20\x78\x20\x3d\x20\x30\x3b\x20\x7d", false, false },
    { "\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x28\x78\x29\x20\x7b\x20\x77\x69\x74\x68\x20\x28\x7b\x7d\x29\x20\x7b\x20\x78\x20\x3d\x20\x31\x3b\x20\x7d\x20\x7d", false, true },
    // Eval approximation.
    { "\x65\x76\x61\x6c\x28\x27\x27\x29\x3b", true, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x68\x28\x29\x20\x7b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b\x20\x7d", true, false },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b\x20\x7d\x29", true, false },
    // Shadowing not recognized because of eval approximation.
    { "\x76\x61\x72\x20\x78\x3b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b", true, false },
    { "\x27\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74\x27\x3b\x20\x6c\x65\x74\x20\x78\x3b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b", true, false },
    { "\x74\x72\x79\x20\x7b\x7d\x20\x63\x61\x74\x63\x68\x28\x78\x29\x20\x7b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b\x20\x7d", true, false },
    { "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x78\x28\x29\x20\x7b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b\x20\x7d", true, false },
    { "\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x78\x29\x20\x7b\x20\x65\x76\x61\x6c\x28\x27\x27\x29\x3b\x20\x7d\x29", true, false },
  };

  // Used to trigger lazy compilation of function
  int comment_len = 2048;
  i::ScopedVector<char> comment(comment_len + 1);
  i::SNPrintF(comment, "\x2f\x2a\x25\x30\x2a\x64\x2a\x2f", comment_len - 4, 0);
  int prefix_len = Utf8LengthHelper(prefix);
  int midfix_len = Utf8LengthHelper(midfix);
  int suffix_len = Utf8LengthHelper(suffix);
  for (unsigned i = 0; i < ARRAY_SIZE(outers); ++i) {
    const char* outer = outers[i].source;
    int outer_len = Utf8LengthHelper(outer);
    for (unsigned j = 0; j < ARRAY_SIZE(inners); ++j) {
      for (unsigned outer_lazy = 0; outer_lazy < 2; ++outer_lazy) {
        for (unsigned inner_lazy = 0; inner_lazy < 2; ++inner_lazy) {
          if (outers[i].strict && inners[j].with) continue;
          const char* inner = inners[j].source;
          int inner_len = Utf8LengthHelper(inner);

          int outer_comment_len = outer_lazy ? comment_len : 0;
          int inner_comment_len = inner_lazy ? comment_len : 0;
          const char* outer_comment = outer_lazy ? comment.start() : "";
          const char* inner_comment = inner_lazy ? comment.start() : "";
          int len = prefix_len + outer_comment_len + outer_len + midfix_len +
                    inner_comment_len + inner_len + suffix_len;
          i::ScopedVector<char> program(len + 1);

          i::SNPrintF(program, "\x6c\xa2\x6c\xa2\x6c\xa2\x6c\xa2\x6c\xa2\x6c\xa2\x6c\xa2", prefix, outer_comment, outer,
                      midfix, inner_comment, inner, suffix);
          i::Handle<i::String> source =
              factory->InternalizeUtf8String(program.start());
          source->PrintOn(stdout);
          printf("\xa");

          i::Handle<i::Script> script = factory->NewScript(source);
          i::CompilationInfoWithZone info(script);
          i::Parser parser(&info);
          parser.set_allow_harmony_scoping(true);
          CHECK(parser.Parse());
          CHECK(i::Rewriter::Rewrite(&info));
          CHECK(i::Scope::Analyze(&info));
          CHECK(info.function() != NULL);

          i::Scope* scope = info.function()->scope();
          CHECK_EQ(scope->inner_scopes()->length(), 1);
          i::Scope* inner_scope = scope->inner_scopes()->at(0);
          const i::AstRawString* var_name =
              info.ast_value_factory()->GetOneByteString("\x78");
          i::Variable* var = inner_scope->Lookup(var_name);
          bool expected = outers[i].assigned || inners[j].assigned;
          CHECK(var != NULL);
          CHECK(var->is_used() || !expected);
          CHECK((var->maybe_assigned() == i::kMaybeAssigned) == expected);
        }
      }
    }
  }
}

namespace {

int* global_use_counts = NULL;

void MockUseCounterCallback(v8::Isolate* isolate,
                            v8::Isolate::UseCounterFeature feature) {
  ++global_use_counts[feature];
}

}


TEST(UseAsmUseCount) {
  i::Isolate* isolate = CcTest::i_isolate();
  i::HandleScope scope(isolate);
  LocalContext env;
  int use_counts[v8::Isolate::kUseCounterFeatureCount] = {};
  global_use_counts = use_counts;
  CcTest::isolate()->SetUseCounterCallback(MockUseCounterCallback);
  CompileRun("\x22\x75\x73\x65\x20\x61\x73\x6d\x22\x3b\xa"
             "\x76\x61\x72\x20\x66\x6f\x6f\x20\x3d\x20\x31\x3b\xa"
             "\x22\x75\x73\x65\x20\x61\x73\x6d\x22\x3b\xa"  // Only the first one counts.
             "\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x62\x61\x72\x28\x29\x20\x7b\x20\x22\x75\x73\x65\x20\x61\x73\x6d\x22\x3b\x20\x76\x61\x72\x20\x62\x61\x7a\x20\x3d\x20\x31\x3b\x20\x7d");
  CHECK_EQ(2, use_counts[v8::Isolate::kUseAsm]);
}


TEST(ErrorsArrowFunctions) {
  // Tests that parser and preparser generate the same kind of errors
  // on invalid arrow function syntax.
  const char* context_data[][2] = {
    {"", "\x3b"},
    {"\x76\x20\x3d\x20", "\x3b"},
    {"\x62\x61\x72\x20\x3f\x20\x28", "\x29\x20\x3a\x20\x62\x61\x7a\x3b"},
    {"\x62\x61\x72\x20\x3f\x20\x62\x61\x7a\x20\x3a\x20\x28", "\x29\x3b"},
    {"\x62\x61\x72\x5b", "\x5d\x3b"},
    {"\x62\x61\x72\x2c\x20", "\x3b"},
    {"", "\x2c\x20\x62\x61\x72\x3b"},
    {NULL, NULL}
  };

  const char* statement_data[] = {
    "\x3d\x3e\x20\x30",
    "\x3d\x3e",
    "\x28\x29\x20\x3d\x3e",
    "\x3d\x3e\x20\x7b\x7d",
    "\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x2c\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x2c\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x72\x65\x74\x75\x72\x6e\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x29\x20\x3d\x3e\x20\x7b\x27\x76\x61\x6c\x75\x65\x27\x3a\x20\x34\x32\x7d",

    // Check that the early return introduced in ParsePrimaryExpression
    // does not accept stray closing parentheses.
    "\x29",
    "\x29\x20\x3d\x3e\x20\x30",
    "\x66\x6f\x6f\x5b\x28\x29\x5d",
    "\x28\x29",

    // Parameter lists with extra parens should be recognized as errors.
    "\x28\x28\x29\x29\x20\x3d\x3e\x20\x30",
    "\x28\x28\x78\x29\x29\x20\x3d\x3e\x20\x30",
    "\x28\x28\x78\x2c\x20\x79\x29\x29\x20\x3d\x3e\x20\x30",
    "\x28\x78\x2c\x20\x28\x79\x29\x29\x20\x3d\x3e\x20\x30",
    "\x28\x28\x78\x2c\x20\x79\x2c\x20\x7a\x29\x29\x20\x3d\x3e\x20\x30",
    "\x28\x78\x2c\x20\x28\x79\x2c\x20\x7a\x29\x29\x20\x3d\x3e\x20\x30",
    "\x28\x28\x78\x2c\x20\x79\x29\x2c\x20\x7a\x29\x20\x3d\x3e\x20\x30",

    // Parameter lists are always validated as strict, so those are errors.
    "\x65\x76\x61\x6c\x20\x3d\x3e\x20\x7b\x7d",
    "\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x3d\x3e\x20\x7b\x7d",
    "\x79\x69\x65\x6c\x64\x20\x3d\x3e\x20\x7b\x7d",
    "\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x65\x76\x61\x6c\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x79\x69\x65\x6c\x64\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x65\x76\x61\x6c\x2c\x20\x62\x61\x72\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x62\x61\x72\x2c\x20\x65\x76\x61\x6c\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x62\x61\x72\x2c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x62\x61\x72\x2c\x20\x79\x69\x65\x6c\x64\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x62\x61\x72\x2c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x29\x20\x3d\x3e\x20\x7b\x7d",
    // TODO(aperez): Detecting duplicates does not work in PreParser.
    // "(bar, bar) => {}",

    // The parameter list is parsed as an expression, but only
    // a comma-separated list of identifier is valid.
    "\x33\x32\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x33\x32\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x33\x32\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x69\x66\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x69\x66\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x69\x66\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x61\x20\x2b\x20\x62\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x20\x2b\x20\x62\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x20\x2b\x20\x62\x2c\x20\x63\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x62\x20\x2d\x20\x63\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x22\x61\x22\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x22\x61\x22\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x22\x61\x22\x2c\x20\x62\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x22\x62\x22\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x2d\x61\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x2d\x61\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x2d\x61\x2c\x20\x62\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x2d\x62\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x7b\x7d\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x7b\x7d\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x7b\x7d\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x7b\x7d\x2c\x20\x61\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x61\x2b\x2b\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2b\x2b\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2b\x2b\x2c\x20\x62\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x62\x2b\x2b\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x5b\x5d\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x5b\x5d\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x5b\x5d\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x5b\x5d\x2c\x20\x61\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x20\x3d\x20\x62\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x20\x3d\x20\x62\x2c\x20\x63\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x62\x20\x3d\x20\x63\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x66\x6f\x6f\x20\x3f\x20\x62\x61\x72\x20\x3a\x20\x62\x61\x7a\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x61\x2c\x20\x66\x6f\x6f\x20\x3f\x20\x62\x61\x72\x20\x3a\x20\x62\x61\x7a\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x66\x6f\x6f\x20\x3f\x20\x62\x61\x72\x20\x3a\x20\x62\x61\x7a\x2c\x20\x61\x29\x20\x3d\x3e\x20\x7b\x7d",
    NULL
  };

  // The test is quite slow, so run it with a reduced set of flags.
  static const ParserFlag flags[] = {
    kAllowLazy, kAllowHarmonyScoping, kAllowGenerators
  };
  static const ParserFlag always_flags[] = { kAllowArrowFunctions };
  RunParserSyncTest(context_data, statement_data, kError, flags,
                    ARRAY_SIZE(flags), always_flags, ARRAY_SIZE(always_flags));
}


TEST(NoErrorsArrowFunctions) {
  // Tests that parser and preparser accept valid arrow functions syntax.
  const char* context_data[][2] = {
    {"", "\x3b"},
    {"\x62\x61\x72\x20\x3f\x20\x28", "\x29\x20\x3a\x20\x62\x61\x7a\x3b"},
    {"\x62\x61\x72\x20\x3f\x20\x62\x61\x7a\x20\x3a\x20\x28", "\x29\x3b"},
    {"\x62\x61\x72\x2c\x20", "\x3b"},
    {"", "\x2c\x20\x62\x61\x72\x3b"},
    {NULL, NULL}
  };

  const char* statement_data[] = {
    "\x28\x29\x20\x3d\x3e\x20\x7b\x7d",
    "\x28\x29\x20\x3d\x3e\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x34\x32\x20\x7d",
    "\x78\x20\x3d\x3e\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x78\x3b\x20\x7d",
    "\x28\x78\x29\x20\x3d\x3e\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x78\x3b\x20\x7d",
    "\x28\x78\x2c\x20\x79\x29\x20\x3d\x3e\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x78\x20\x2b\x20\x79\x3b\x20\x7d",
    "\x28\x78\x2c\x20\x79\x2c\x20\x7a\x29\x20\x3d\x3e\x20\x7b\x20\x72\x65\x74\x75\x72\x6e\x20\x78\x20\x2b\x20\x79\x20\x2b\x20\x7a\x3b\x20\x7d",
    "\x28\x78\x2c\x20\x79\x29\x20\x3d\x3e\x20\x7b\x20\x78\x2e\x61\x20\x3d\x20\x79\x3b\x20\x7d",
    "\x28\x29\x20\x3d\x3e\x20\x34\x32",
    "\x78\x20\x3d\x3e\x20\x78",
    "\x78\x20\x3d\x3e\x20\x78\x20\x2a\x20\x78",
    "\x28\x78\x29\x20\x3d\x3e\x20\x78",
    "\x28\x78\x29\x20\x3d\x3e\x20\x78\x20\x2a\x20\x78",
    "\x28\x78\x2c\x20\x79\x29\x20\x3d\x3e\x20\x78\x20\x2b\x20\x79",
    "\x28\x78\x2c\x20\x79\x2c\x20\x7a\x29\x20\x3d\x3e\x20\x78\x2c\x20\x79\x2c\x20\x7a",
    "\x28\x78\x2c\x20\x79\x29\x20\x3d\x3e\x20\x78\x2e\x61\x20\x3d\x20\x79",
    "\x28\x29\x20\x3d\x3e\x20\x28\x7b\x27\x76\x61\x6c\x75\x65\x27\x3a\x20\x34\x32\x7d\x29",
    "\x78\x20\x3d\x3e\x20\x79\x20\x3d\x3e\x20\x78\x20\x2b\x20\x79",
    "\x28\x78\x2c\x20\x79\x29\x20\x3d\x3e\x20\x28\x75\x2c\x20\x76\x29\x20\x3d\x3e\x20\x78\x2a\x75\x20\x2b\x20\x79\x2a\x76",
    "\x28\x78\x2c\x20\x79\x29\x20\x3d\x3e\x20\x7a\x20\x3d\x3e\x20\x7a\x20\x2a\x20\x28\x78\x20\x2b\x20\x79\x29",
    "\x78\x20\x3d\x3e\x20\x28\x79\x2c\x20\x7a\x29\x20\x3d\x3e\x20\x7a\x20\x2a\x20\x28\x78\x20\x2b\x20\x79\x29",

    // Those are comma-separated expressions, with arrow functions as items.
    // They stress the code for validating arrow function parameter lists.
    "\x61\x2c\x20\x62\x20\x3d\x3e\x20\x30",
    "\x61\x2c\x20\x62\x2c\x20\x28\x63\x2c\x20\x64\x29\x20\x3d\x3e\x20\x30",
    "\x28\x61\x2c\x20\x62\x2c\x20\x28\x63\x2c\x20\x64\x29\x20\x3d\x3e\x20\x30\x29",
    "\x28\x61\x2c\x20\x62\x29\x20\x3d\x3e\x20\x30\x2c\x20\x28\x63\x2c\x20\x64\x29\x20\x3d\x3e\x20\x31",
    "\x28\x61\x2c\x20\x62\x20\x3d\x3e\x20\x7b\x7d\x2c\x20\x61\x20\x3d\x3e\x20\x61\x20\x2b\x20\x31\x29",
    "\x28\x28\x61\x2c\x20\x62\x29\x20\x3d\x3e\x20\x7b\x7d\x2c\x20\x28\x61\x20\x3d\x3e\x20\x61\x20\x2b\x20\x31\x29\x29",
    "\x28\x61\x2c\x20\x28\x61\x2c\x20\x28\x62\x2c\x20\x63\x29\x20\x3d\x3e\x20\x30\x29\x29",

    // Arrow has more precedence, this is the same as: foo ? bar : (baz = {})
    "\x66\x6f\x6f\x20\x3f\x20\x62\x61\x72\x20\x3a\x20\x62\x61\x7a\x20\x3d\x3e\x20\x7b\x7d",
    NULL
  };

  static const ParserFlag always_flags[] = {kAllowArrowFunctions};
  RunParserSyncTest(context_data, statement_data, kSuccess, NULL, 0,
                    always_flags, ARRAY_SIZE(always_flags));
}
